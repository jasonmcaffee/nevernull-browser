{"version":3,"sources":["../src/nevernull.js"],"names":["global","isStandardAttribute","name","test","toPropertyDescriptor","obj","Object","TypeError","desc","enumerable","configurable","value","writable","getter","get","setter","set","isAccessorDescriptor","isDataDescriptor","isGenericDescriptor","toCompletePropertyDescriptor","internalDesc","isEmptyDescriptor","isEquivalentDescriptor","desc1","desc2","sameValue","x","y","normalizeAndCompletePropertyDescriptor","attributes","defineProperty","normalizePropertyDescriptor","isFixed","target","hasOwnProperty","call","isSealed","getOwnPropertyDescriptor","isSealedDesc","isCompatibleDescriptor","extensible","current","setIntegrityLevel","level","ownProps","Object_getOwnPropertyNames","pendingException","l","length","k","i","e","currentDesc","Reflect","preventExtensions","testIntegrityLevel","isExtensible","Object_isExtensible","Validator","handler","isObject","arg","type","safeWeakMapGet","map","key","makeUnwrapping0ArgMethod","primitive","builtin","vHandler","directProxies","isProxyArray","Array","isArray","WeakMap","prototype","Error","prim_preventExtensions","prim_seal","seal","prim_freeze","freeze","prim_isExtensible","prim_isSealed","prim_isFrozen","isFrozen","prim_getPrototypeOf","getPrototypeOf","prim_getOwnPropertyDescriptor","prim_defineProperty","prim_defineProperties","defineProperties","prim_keys","keys","prim_getOwnPropertyNames","getOwnPropertyNames","prim_getOwnPropertySymbols","getOwnPropertySymbols","prim_assign","assign","prim_isArray","prim_concat","concat","prim_isPrototypeOf","isPrototypeOf","prim_hasOwnProperty","Object_isFrozen","Object_isSealed","Object_getPrototypeOf","getTrap","trapName","trap","targetDesc","getPropertyDescriptor","has","val","descObj","success","delete","deleteProperty","res","ownKeys","trapResult","propNames","create","numProps","result","s","forEach","ownProp","state","allegedProto","actualProto","setPrototypeOf","newProto","getPropertyNames","receiver","fixedDesc","enumerate","nxt","next","done","push","ownEnumerableProps","ownEnumerableProp","iterate","apply","thisBinding","args","construct","newTarget","subject","vhandler","normalizedDesc","descs","names","noProxies","arguments","output","index","source","nextKey","valueOf","toString","Function","Date","vHandler2","slice","prim_setPrototypeOf","__proto__setter","protoDesc","proto","ownDesc","existingDesc","updateDesc","idx","bind","Proxy","primCreate","primCreateFunction","createFunction","revokedHandler","proxy","revocable","revoke","exports","nn","rawValue","rawTarget","rawPropertyValue"],"mappings":"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","file":"nevernull.js","sourcesContent":["// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n// ----------------------------------------------------------------------------\n\n// This file is a polyfill for the upcoming ECMAScript Reflect API,\n// including support for Proxies. See the draft specification at:\n// http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// For an implementation of the Handler API, see handlers.js, which implements:\n// http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n// This implementation supersedes the earlier polyfill at:\n// code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n// This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n// The code also works correctly on\n//   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n// Language Dependencies:\n//  - ECMAScript 5/strict\n//  - \"old\" (i.e. non-direct) Harmony Proxies\n//  - Harmony WeakMaps\n// Patches:\n//  - Object.{freeze,seal,preventExtensions}\n//  - Object.{isFrozen,isSealed,isExtensible}\n//  - Object.getPrototypeOf\n//  - Object.keys\n//  - Object.prototype.valueOf\n//  - Object.prototype.isPrototypeOf\n//  - Object.prototype.toString\n//  - Object.prototype.hasOwnProperty\n//  - Object.getOwnPropertyDescriptor\n//  - Object.defineProperty\n//  - Object.defineProperties\n//  - Object.getOwnPropertyNames\n//  - Object.getOwnPropertySymbols\n//  - Object.getPrototypeOf\n//  - Object.setPrototypeOf\n//  - Object.assign\n//  - Function.prototype.toString\n//  - Date.prototype.toString\n//  - Array.isArray\n//  - Array.prototype.concat\n//  - Proxy\n// Adds new globals:\n//  - Reflect\n\n// Direct proxies can be created via Proxy(target, handler)\n\n// ----------------------------------------------------------------------------\n\n(function(global){ // function-as-module pattern\n    \"use strict\";\n\n// === Direct Proxies: Invariant Enforcement ===\n\n// Direct proxies build on non-direct proxies by automatically wrapping\n// all user-defined proxy handlers in a Validator handler that checks and\n// enforces ES5 invariants.\n\n// A direct proxy is a proxy for an existing object called the target object.\n\n// A Validator handler is a wrapper for a target proxy handler H.\n// The Validator forwards all operations to H, but additionally\n// performs a number of integrity checks on the results of some traps,\n// to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n// properties and non-extensible, sealed or frozen objects.\n\n// For each property that H exposes as own, non-configurable\n// (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n// the Validator handler defines those properties on the target object.\n// When the proxy becomes non-extensible, also configurable own properties\n// are checked against the target.\n// We will call properties that are defined on the target object\n// \"fixed properties\".\n\n// We will name fixed non-configurable properties \"sealed properties\".\n// We will name fixed non-configurable non-writable properties \"frozen\n// properties\".\n\n// The Validator handler upholds the following invariants w.r.t. non-configurability:\n// - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n// - getOwnPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property (e.g. reporting a non-configurable\n//   property as configurable, or reporting a non-configurable, non-writable\n//   property as writable)\n// - getPropertyDescriptor cannot report sealed properties as non-existent\n// - getPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property. It _can_ report incompatible changes\n//   to the attributes of non-own, inherited properties.\n// - defineProperty cannot make incompatible changes to the attributes of\n//   sealed properties\n// - deleteProperty cannot report a successful deletion of a sealed property\n// - hasOwn cannot report a sealed property as non-existent\n// - has cannot report a sealed property as non-existent\n// - get cannot report inconsistent values for frozen data\n//   properties, and must report undefined for sealed accessors with an\n//   undefined getter\n// - set cannot report a successful assignment for frozen data\n//   properties or sealed accessors with an undefined setter.\n// - get{Own}PropertyNames lists all sealed properties of the target.\n// - keys lists all enumerable sealed properties of the target.\n// - enumerate lists all enumerable sealed properties of the target.\n// - if a property of a non-extensible proxy is reported as non-existent,\n//   then it must forever be reported as non-existent. This applies to\n//   own and inherited properties and is enforced in the\n//   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n//   get{Own}PropertyNames, keys and enumerate traps\n\n// Violation of any of these invariants by H will result in TypeError being\n// thrown.\n\n// Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n// is invoked on the proxy, the set of own property names for the proxy is\n// fixed. Any property name that is not fixed is called a 'new' property.\n\n// The Validator upholds the following invariants regarding extensibility:\n// - getOwnPropertyDescriptor cannot report new properties as existent\n//   (it must report them as non-existent by returning undefined)\n// - defineProperty cannot successfully add a new property (it must reject)\n// - getOwnPropertyNames cannot list new properties\n// - hasOwn cannot report true for new properties (it must report false)\n// - keys cannot list new properties\n\n// Invariants currently not enforced:\n// - getOwnPropertyNames lists only own property names\n// - keys lists only enumerable own property names\n// Both traps may list more property names than are actually defined on the\n// target.\n\n// Invariants with regard to inheritance are currently not enforced.\n// - a non-configurable potentially inherited property on a proxy with\n//   non-mutable ancestry cannot be reported as non-existent\n// (An object with non-mutable ancestry is a non-extensible object whose\n// [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n// Changes in Handler API compared to previous harmony:proxies, see:\n// http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// ----------------------------------------------------------------------------\n\n// ---- WeakMap polyfill ----\n\n// TODO: find a proper WeakMap polyfill\n\n// define an empty WeakMap so that at least the Reflect module code\n// will work in the absence of WeakMaps. Proxy emulation depends on\n// actual WeakMaps, so will not work with this little shim.\n    if (typeof WeakMap === \"undefined\") {\n        global.WeakMap = function(){};\n        global.WeakMap.prototype = {\n            get: function(k) { return undefined; },\n            set: function(k,v) { throw new Error(\"WeakMap not supported\"); }\n        };\n    }\n\n// ---- Normalization functions for property descriptors ----\n\n    function isStandardAttribute(name) {\n        return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n    }\n\n// Adapted from ES5 section 8.10.5\n    function toPropertyDescriptor(obj) {\n        if (Object(obj) !== obj) {\n            throw new TypeError(\"property descriptor should be an Object, given: \"+\n                obj);\n        }\n        var desc = {};\n        if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n        if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n        if ('value' in obj) { desc.value = obj.value; }\n        if ('writable' in obj) { desc.writable = !!obj.writable; }\n        if ('get' in obj) {\n            var getter = obj.get;\n            if (getter !== undefined && typeof getter !== \"function\") {\n                throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                    \"callable or undefined, given: \"+getter);\n            }\n            desc.get = getter;\n        }\n        if ('set' in obj) {\n            var setter = obj.set;\n            if (setter !== undefined && typeof setter !== \"function\") {\n                throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                    \"callable or undefined, given: \"+setter);\n            }\n            desc.set = setter;\n        }\n        if ('get' in desc || 'set' in desc) {\n            if ('value' in desc || 'writable' in desc) {\n                throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                    \"accessor descriptor: \"+obj);\n            }\n        }\n        return desc;\n    }\n\n    function isAccessorDescriptor(desc) {\n        if (desc === undefined) return false;\n        return ('get' in desc || 'set' in desc);\n    }\n    function isDataDescriptor(desc) {\n        if (desc === undefined) return false;\n        return ('value' in desc || 'writable' in desc);\n    }\n    function isGenericDescriptor(desc) {\n        if (desc === undefined) return false;\n        return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n    }\n\n    function toCompletePropertyDescriptor(desc) {\n        var internalDesc = toPropertyDescriptor(desc);\n        if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n            if (!('value' in internalDesc)) { internalDesc.value = undefined; }\n            if (!('writable' in internalDesc)) { internalDesc.writable = false; }\n        } else {\n            if (!('get' in internalDesc)) { internalDesc.get = undefined; }\n            if (!('set' in internalDesc)) { internalDesc.set = undefined; }\n        }\n        if (!('enumerable' in internalDesc)) { internalDesc.enumerable = false; }\n        if (!('configurable' in internalDesc)) { internalDesc.configurable = false; }\n        return internalDesc;\n    }\n\n    function isEmptyDescriptor(desc) {\n        return !('get' in desc) &&\n            !('set' in desc) &&\n            !('value' in desc) &&\n            !('writable' in desc) &&\n            !('enumerable' in desc) &&\n            !('configurable' in desc);\n    }\n\n    function isEquivalentDescriptor(desc1, desc2) {\n        return sameValue(desc1.get, desc2.get) &&\n            sameValue(desc1.set, desc2.set) &&\n            sameValue(desc1.value, desc2.value) &&\n            sameValue(desc1.writable, desc2.writable) &&\n            sameValue(desc1.enumerable, desc2.enumerable) &&\n            sameValue(desc1.configurable, desc2.configurable);\n    }\n\n// copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\n    function sameValue(x, y) {\n        if (x === y) {\n            // 0 === -0, but they are not identical\n            return x !== 0 || 1 / x === 1 / y;\n        }\n\n        // NaN !== NaN, but they are identical.\n        // NaNs are the only non-reflexive value, i.e., if x !== x,\n        // then x is a NaN.\n        // isNaN is broken: it converts its argument to number, so\n        // isNaN(\"foo\") => true\n        return x !== x && y !== y;\n    }\n\n    /**\n     * Returns a fresh property descriptor that is guaranteed\n     * to be complete (i.e. contain all the standard attributes).\n     * Additionally, any non-standard enumerable properties of\n     * attributes are copied over to the fresh descriptor.\n     *\n     * If attributes is undefined, returns undefined.\n     *\n     * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n     */\n    function normalizeAndCompletePropertyDescriptor(attributes) {\n        if (attributes === undefined) { return undefined; }\n        var desc = toCompletePropertyDescriptor(attributes);\n        // Note: no need to call FromPropertyDescriptor(desc), as we represent\n        // \"internal\" property descriptors as proper Objects from the start\n        for (var name in attributes) {\n            if (!isStandardAttribute(name)) {\n                Object.defineProperty(desc, name,\n                    { value: attributes[name],\n                        writable: true,\n                        enumerable: true,\n                        configurable: true });\n            }\n        }\n        return desc;\n    }\n\n    /**\n     * Returns a fresh property descriptor whose standard\n     * attributes are guaranteed to be data properties of the right type.\n     * Additionally, any non-standard enumerable properties of\n     * attributes are copied over to the fresh descriptor.\n     *\n     * If attributes is undefined, will throw a TypeError.\n     *\n     * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n     */\n    function normalizePropertyDescriptor(attributes) {\n        var desc = toPropertyDescriptor(attributes);\n        // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n        // \"internal\" property descriptors as proper Objects from the start\n        for (var name in attributes) {\n            if (!isStandardAttribute(name)) {\n                Object.defineProperty(desc, name,\n                    { value: attributes[name],\n                        writable: true,\n                        enumerable: true,\n                        configurable: true });\n            }\n        }\n        return desc;\n    }\n\n// store a reference to the real ES5 primitives before patching them later\n    var prim_preventExtensions =        Object.preventExtensions,\n        prim_seal =                     Object.seal,\n        prim_freeze =                   Object.freeze,\n        prim_isExtensible =             Object.isExtensible,\n        prim_isSealed =                 Object.isSealed,\n        prim_isFrozen =                 Object.isFrozen,\n        prim_getPrototypeOf =           Object.getPrototypeOf,\n        prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n        prim_defineProperty =           Object.defineProperty,\n        prim_defineProperties =         Object.defineProperties,\n        prim_keys =                     Object.keys,\n        prim_getOwnPropertyNames =      Object.getOwnPropertyNames,\n        prim_getOwnPropertySymbols =    Object.getOwnPropertySymbols,\n        prim_assign =                   Object.assign,\n        prim_isArray =                  Array.isArray,\n        prim_concat =                   Array.prototype.concat,\n        prim_isPrototypeOf =            Object.prototype.isPrototypeOf,\n        prim_hasOwnProperty =           Object.prototype.hasOwnProperty;\n\n// these will point to the patched versions of the respective methods on\n// Object. They are used within this module as the \"intrinsic\" bindings\n// of these methods (i.e. the \"original\" bindings as defined in the spec)\n    var Object_isFrozen,\n        Object_isSealed,\n        Object_isExtensible,\n        Object_getPrototypeOf,\n        Object_getOwnPropertyNames;\n\n    /**\n     * A property 'name' is fixed if it is an own property of the target.\n     */\n    function isFixed(name, target) {\n        return ({}).hasOwnProperty.call(target, name);\n    }\n    function isSealed(name, target) {\n        var desc = Object.getOwnPropertyDescriptor(target, name);\n        if (desc === undefined) { return false; }\n        return desc.configurable === false;\n    }\n    function isSealedDesc(desc) {\n        return desc !== undefined && desc.configurable === false;\n    }\n\n    /**\n     * Performs all validation that Object.defineProperty performs,\n     * without actually defining the property. Returns a boolean\n     * indicating whether validation succeeded.\n     *\n     * Implementation transliterated from ES5.1 section 8.12.9\n     */\n    function isCompatibleDescriptor(extensible, current, desc) {\n        if (current === undefined && extensible === false) {\n            return false;\n        }\n        if (current === undefined && extensible === true) {\n            return true;\n        }\n        if (isEmptyDescriptor(desc)) {\n            return true;\n        }\n        if (isEquivalentDescriptor(current, desc)) {\n            return true;\n        }\n        if (current.configurable === false) {\n            if (desc.configurable === true) {\n                return false;\n            }\n            if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n                return false;\n            }\n        }\n        if (isGenericDescriptor(desc)) {\n            return true;\n        }\n        if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n            if (current.configurable === false) {\n                return false;\n            }\n            return true;\n        }\n        if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n            if (current.configurable === false) {\n                if (current.writable === false && desc.writable === true) {\n                    return false;\n                }\n                if (current.writable === false) {\n                    if ('value' in desc && !sameValue(desc.value, current.value)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n            if (current.configurable === false) {\n                if ('set' in desc && !sameValue(desc.set, current.set)) {\n                    return false;\n                }\n                if ('get' in desc && !sameValue(desc.get, current.get)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n// ES6 7.3.11 SetIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\n    function setIntegrityLevel(target, level) {\n        var ownProps = Object_getOwnPropertyNames(target);\n        var pendingException = undefined;\n        if (level === \"sealed\") {\n            var l = +ownProps.length;\n            var k;\n            for (var i = 0; i < l; i++) {\n                k = String(ownProps[i]);\n                try {\n                    Object.defineProperty(target, k, { configurable: false });\n                } catch (e) {\n                    if (pendingException === undefined) {\n                        pendingException = e;\n                    }\n                }\n            }\n        } else {\n            // level === \"frozen\"\n            var l = +ownProps.length;\n            var k;\n            for (var i = 0; i < l; i++) {\n                k = String(ownProps[i]);\n                try {\n                    var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n                    if (currentDesc !== undefined) {\n                        var desc;\n                        if (isAccessorDescriptor(currentDesc)) {\n                            desc = { configurable: false }\n                        } else {\n                            desc = { configurable: false, writable: false }\n                        }\n                        Object.defineProperty(target, k, desc);\n                    }\n                } catch (e) {\n                    if (pendingException === undefined) {\n                        pendingException = e;\n                    }\n                }\n            }\n        }\n        if (pendingException !== undefined) {\n            throw pendingException;\n        }\n        return Reflect.preventExtensions(target);\n    }\n\n// ES6 7.3.12 TestIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\n    function testIntegrityLevel(target, level) {\n        var isExtensible = Object_isExtensible(target);\n        if (isExtensible) return false;\n\n        var ownProps = Object_getOwnPropertyNames(target);\n        var pendingException = undefined;\n        var configurable = false;\n        var writable = false;\n\n        var l = +ownProps.length;\n        var k;\n        var currentDesc;\n        for (var i = 0; i < l; i++) {\n            k = String(ownProps[i]);\n            try {\n                currentDesc = Object.getOwnPropertyDescriptor(target, k);\n                configurable = configurable || currentDesc.configurable;\n                if (isDataDescriptor(currentDesc)) {\n                    writable = writable || currentDesc.writable;\n                }\n            } catch (e) {\n                if (pendingException === undefined) {\n                    pendingException = e;\n                    configurable = true;\n                }\n            }\n        }\n        if (pendingException !== undefined) {\n            throw pendingException;\n        }\n        if (level === \"frozen\" && writable === true) {\n            return false;\n        }\n        if (configurable === true) {\n            return false;\n        }\n        return true;\n    }\n\n// ---- The Validator handler wrapper around user handlers ----\n\n    /**\n     * @param target the object wrapped by this proxy.\n     * As long as the proxy is extensible, only non-configurable properties\n     * are checked against the target. Once the proxy becomes non-extensible,\n     * invariants w.r.t. non-extensibility are also enforced.\n     *\n     * @param handler the handler of the direct proxy. The object emulated by\n     * this handler is validated against the target object of the direct proxy.\n     * Any violations that the handler makes against the invariants\n     * of the target will cause a TypeError to be thrown.\n     *\n     * Both target and handler must be proper Objects at initialization time.\n     */\n    function Validator(target, handler) {\n        // for non-revokable proxies, these are const references\n        // for revokable proxies, on revocation:\n        // - this.target is set to null\n        // - this.handler is set to a handler that throws on all traps\n        this.target  = target;\n        this.handler = handler;\n    }\n\n    Validator.prototype = {\n\n        /**\n         * If getTrap returns undefined, the caller should perform the\n         * default forwarding behavior.\n         * If getTrap returns normally otherwise, the return value\n         * will be a callable trap function. When calling the trap function,\n         * the caller is responsible for binding its |this| to |this.handler|.\n         */\n        getTrap: function(trapName) {\n            var trap = this.handler[trapName];\n            if (trap === undefined) {\n                // the trap was not defined,\n                // perform the default forwarding behavior\n                return undefined;\n            }\n\n            if (typeof trap !== \"function\") {\n                throw new TypeError(trapName + \" trap is not callable: \"+trap);\n            }\n\n            return trap;\n        },\n\n        // === fundamental traps ===\n\n        /**\n         * If name denotes a fixed property, check:\n         *   - whether targetHandler reports it as existent\n         *   - whether the returned descriptor is compatible with the fixed property\n         * If the proxy is non-extensible, check:\n         *   - whether name is not a new property\n         * Additionally, the returned descriptor is normalized and completed.\n         */\n        getOwnPropertyDescriptor: function(name) {\n            \"use strict\";\n\n            var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n            if (trap === undefined) {\n                return Reflect.getOwnPropertyDescriptor(this.target, name);\n            }\n\n            name = String(name);\n            var desc = trap.call(this.handler, this.target, name);\n            desc = normalizeAndCompletePropertyDescriptor(desc);\n\n            var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n            var extensible = Object.isExtensible(this.target);\n\n            if (desc === undefined) {\n                if (isSealedDesc(targetDesc)) {\n                    throw new TypeError(\"cannot report non-configurable property '\"+name+\n                        \"' as non-existent\");\n                }\n                if (!extensible && targetDesc !== undefined) {\n                    // if handler is allowed to return undefined, we cannot guarantee\n                    // that it will not return a descriptor for this property later.\n                    // Once a property has been reported as non-existent on a non-extensible\n                    // object, it should forever be reported as non-existent\n                    throw new TypeError(\"cannot report existing own property '\"+name+\n                        \"' as non-existent on a non-extensible object\");\n                }\n                return undefined;\n            }\n\n            // at this point, we know (desc !== undefined), i.e.\n            // targetHandler reports 'name' as an existing property\n\n            // Note: we could collapse the following two if-tests into a single\n            // test. Separating out the cases to improve error reporting.\n\n            if (!extensible) {\n                if (targetDesc === undefined) {\n                    throw new TypeError(\"cannot report a new own property '\"+\n                        name + \"' on a non-extensible object\");\n                }\n            }\n\n            if (name !== undefined) {\n                if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n                    throw new TypeError(\"cannot report incompatible property descriptor \"+\n                        \"for property '\"+name+\"'\");\n                }\n            }\n\n            if (desc.configurable === false) {\n                if (targetDesc === undefined || targetDesc.configurable === true) {\n                    // if the property is configurable or non-existent on the target,\n                    // but is reported as a non-configurable property, it may later be\n                    // reported as configurable or non-existent, which violates the\n                    // invariant that if the property might change or disappear, the\n                    // configurable attribute must be true.\n                    throw new TypeError(\n                        \"cannot report a non-configurable descriptor \" +\n                        \"for configurable or non-existent property '\" + name + \"'\");\n                }\n                if ('writable' in desc && desc.writable === false) {\n                    if (targetDesc.writable === true) {\n                        // if the property is non-configurable, writable on the target,\n                        // but is reported as non-configurable, non-writable, it may later\n                        // be reported as non-configurable, writable again, which violates\n                        // the invariant that a non-configurable, non-writable property\n                        // may not change state.\n                        throw new TypeError(\n                            \"cannot report non-configurable, writable property '\" + name +\n                            \"' as non-configurable, non-writable\");\n                    }\n                }\n            }\n\n            return desc;\n        },\n\n        /**\n         * In the direct proxies design with refactored prototype climbing,\n         * this trap is deprecated. For proxies-as-prototypes, instead\n         * of calling this trap, the get, set, has or enumerate traps are\n         * called instead.\n         *\n         * In this implementation, we \"abuse\" getPropertyDescriptor to\n         * support trapping the get or set traps for proxies-as-prototypes.\n         * We do this by returning a getter/setter pair that invokes\n         * the corresponding traps.\n         *\n         * While this hack works for inherited property access, it has some\n         * quirks:\n         *\n         * In Firefox, this trap is only called after a prior invocation\n         * of the 'has' trap has returned true. Hence, expect the following\n         * behavior:\n         * <code>\n         * var child = Object.create(Proxy(target, handler));\n         * child[name] // triggers handler.has(target, name)\n         * // if that returns true, triggers handler.get(target, name, child)\n         * </code>\n         *\n         * On v8, the 'in' operator, when applied to an object that inherits\n         * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n         * That calls the below getPropertyDescriptor trap on the proxy. The\n         * result of the 'in'-operator is then determined by whether this trap\n         * returns undefined or a property descriptor object. That is why\n         * we first explicitly trigger the 'has' trap to determine whether\n         * the property exists.\n         *\n         * This has the side-effect that when enumerating properties on\n         * an object that inherits from a proxy in v8, only properties\n         * for which 'has' returns true are returned:\n         *\n         * <code>\n         * var child = Object.create(Proxy(target, handler));\n         * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n         * </code>\n         */\n        getPropertyDescriptor: function(name) {\n            var handler = this;\n\n            if (!handler.has(name)) return undefined;\n\n            return {\n                get: function() {\n                    return handler.get(this, name);\n                },\n                set: function(val) {\n                    if (handler.set(this, name, val)) {\n                        return val;\n                    } else {\n                        throw new TypeError(\"failed assignment to \"+name);\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            };\n        },\n\n        /**\n         * If name denotes a fixed property, check for incompatible changes.\n         * If the proxy is non-extensible, check that new properties are rejected.\n         */\n        defineProperty: function(name, desc) {\n            // TODO(tvcutsem): the current tracemonkey implementation of proxies\n            // auto-completes 'desc', which is not correct. 'desc' should be\n            // normalized, but not completed. Consider:\n            // Object.defineProperty(proxy, 'foo', {enumerable:false})\n            // This trap will receive desc =\n            //  {value:undefined,writable:false,enumerable:false,configurable:false}\n            // This will also set all other attributes to their default value,\n            // which is unexpected and different from [[DefineOwnProperty]].\n            // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n            var trap = this.getTrap(\"defineProperty\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.defineProperty(this.target, name, desc);\n            }\n\n            name = String(name);\n            var descObj = normalizePropertyDescriptor(desc);\n            var success = trap.call(this.handler, this.target, name, descObj);\n            success = !!success; // coerce to Boolean\n\n            if (success === true) {\n\n                var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                var extensible = Object.isExtensible(this.target);\n\n                // Note: we could collapse the following two if-tests into a single\n                // test. Separating out the cases to improve error reporting.\n\n                if (!extensible) {\n                    if (targetDesc === undefined) {\n                        throw new TypeError(\"cannot successfully add a new property '\"+\n                            name + \"' to a non-extensible object\");\n                    }\n                }\n\n                if (targetDesc !== undefined) {\n                    if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n                        throw new TypeError(\"cannot define incompatible property \"+\n                            \"descriptor for property '\"+name+\"'\");\n                    }\n                    if (isDataDescriptor(targetDesc) &&\n                        targetDesc.configurable === false &&\n                        targetDesc.writable === true) {\n                        if (desc.configurable === false && desc.writable === false) {\n                            // if the property is non-configurable, writable on the target\n                            // but was successfully reported to be updated to\n                            // non-configurable, non-writable, it can later be reported\n                            // again as non-configurable, writable, which violates\n                            // the invariant that non-configurable, non-writable properties\n                            // cannot change state\n                            throw new TypeError(\n                                \"cannot successfully define non-configurable, writable \" +\n                                \" property '\" + name + \"' as non-configurable, non-writable\");\n                        }\n                    }\n                }\n\n                if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n                    // if the property is configurable or non-existent on the target,\n                    // but is successfully being redefined as a non-configurable property,\n                    // it may later be reported as configurable or non-existent, which violates\n                    // the invariant that if the property might change or disappear, the\n                    // configurable attribute must be true.\n                    throw new TypeError(\n                        \"cannot successfully define a non-configurable \" +\n                        \"descriptor for configurable or non-existent property '\" +\n                        name + \"'\");\n                }\n\n            }\n\n            return success;\n        },\n\n        /**\n         * On success, check whether the target object is indeed non-extensible.\n         */\n        preventExtensions: function() {\n            var trap = this.getTrap(\"preventExtensions\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.preventExtensions(this.target);\n            }\n\n            var success = trap.call(this.handler, this.target);\n            success = !!success; // coerce to Boolean\n            if (success) {\n                if (Object_isExtensible(this.target)) {\n                    throw new TypeError(\"can't report extensible object as non-extensible: \"+\n                        this.target);\n                }\n            }\n            return success;\n        },\n\n        /**\n         * If name denotes a sealed property, check whether handler rejects.\n         */\n        delete: function(name) {\n            \"use strict\";\n            var trap = this.getTrap(\"deleteProperty\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.deleteProperty(this.target, name);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name);\n            res = !!res; // coerce to Boolean\n\n            var targetDesc;\n            if (res === true) {\n                targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                if (targetDesc !== undefined && targetDesc.configurable === false) {\n                    throw new TypeError(\"property '\" + name + \"' is non-configurable \"+\n                        \"and can't be deleted\");\n                }\n                if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n                    // if the property still exists on a non-extensible target but\n                    // is reported as successfully deleted, it may later be reported\n                    // as present, which violates the invariant that an own property,\n                    // deleted from a non-extensible object cannot reappear.\n                    throw new TypeError(\n                        \"cannot successfully delete existing property '\" + name +\n                        \"' on a non-extensible object\");\n                }\n            }\n\n            return res;\n        },\n\n        /**\n         * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n         * which now also returns an array (of strings or symbols) and\n         * which performs the same rigorous invariant checks as getOwnPropertyNames\n         *\n         * See issue #48 on how this trap can still get invoked by external libs\n         * that don't use the patched Object.getOwnPropertyNames function.\n         */\n        getOwnPropertyNames: function() {\n            // Note: removed deprecation warning to avoid dependency on 'console'\n            // (and on node, should anyway use util.deprecate). Deprecation warnings\n            // can also be annoying when they are outside of the user's control, e.g.\n            // when an external library calls unpatched Object.getOwnPropertyNames.\n            // Since there is a clean fallback to `ownKeys`, the fact that the\n            // deprecated method is still called is mostly harmless anyway.\n            // See also issues #65 and #66.\n            // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n            return this.ownKeys();\n        },\n\n        /**\n         * Checks whether the trap result does not contain any new properties\n         * if the proxy is non-extensible.\n         *\n         * Any own non-configurable properties of the target that are not included\n         * in the trap result give rise to a TypeError. As such, we check whether the\n         * returned result contains at least all sealed properties of the target\n         * object.\n         *\n         * Additionally, the trap result is normalized.\n         * Instead of returning the trap result directly:\n         *  - create and return a fresh Array,\n         *  - of which each element is coerced to a String\n         *\n         * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n         * and Object.keys (the latter filters out only the enumerable own properties).\n         */\n        ownKeys: function() {\n            var trap = this.getTrap(\"ownKeys\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.ownKeys(this.target);\n            }\n\n            var trapResult = trap.call(this.handler, this.target);\n\n            // propNames is used as a set of strings\n            var propNames = Object.create(null);\n            var numProps = +trapResult.length;\n            var result = new Array(numProps);\n\n            for (var i = 0; i < numProps; i++) {\n                var s = String(trapResult[i]);\n                if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n                    // non-extensible proxies don't tolerate new own property names\n                    throw new TypeError(\"ownKeys trap cannot list a new \"+\n                        \"property '\"+s+\"' on a non-extensible object\");\n                }\n\n                propNames[s] = true;\n                result[i] = s;\n            }\n\n            var ownProps = Object_getOwnPropertyNames(this.target);\n            var target = this.target;\n            ownProps.forEach(function (ownProp) {\n                if (!propNames[ownProp]) {\n                    if (isSealed(ownProp, target)) {\n                        throw new TypeError(\"ownKeys trap failed to include \"+\n                            \"non-configurable property '\"+ownProp+\"'\");\n                    }\n                    if (!Object.isExtensible(target) &&\n                        isFixed(ownProp, target)) {\n                        // if handler is allowed to report ownProp as non-existent,\n                        // we cannot guarantee that it will never later report it as\n                        // existent. Once a property has been reported as non-existent\n                        // on a non-extensible object, it should forever be reported as\n                        // non-existent\n                        throw new TypeError(\"ownKeys trap cannot report existing own property '\"+\n                            ownProp+\"' as non-existent on a non-extensible object\");\n                    }\n                }\n            });\n\n            return result;\n        },\n\n        /**\n         * Checks whether the trap result is consistent with the state of the\n         * wrapped target.\n         */\n        isExtensible: function() {\n            var trap = this.getTrap(\"isExtensible\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.isExtensible(this.target);\n            }\n\n            var result = trap.call(this.handler, this.target);\n            result = !!result; // coerce to Boolean\n            var state = Object_isExtensible(this.target);\n            if (result !== state) {\n                if (result) {\n                    throw new TypeError(\"cannot report non-extensible object as extensible: \"+\n                        this.target);\n                } else {\n                    throw new TypeError(\"cannot report extensible object as non-extensible: \"+\n                        this.target);\n                }\n            }\n            return state;\n        },\n\n        /**\n         * Check whether the trap result corresponds to the target's [[Prototype]]\n         */\n        getPrototypeOf: function() {\n            var trap = this.getTrap(\"getPrototypeOf\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.getPrototypeOf(this.target);\n            }\n\n            var allegedProto = trap.call(this.handler, this.target);\n\n            if (!Object_isExtensible(this.target)) {\n                var actualProto = Object_getPrototypeOf(this.target);\n                if (!sameValue(allegedProto, actualProto)) {\n                    throw new TypeError(\"prototype value does not match: \" + this.target);\n                }\n            }\n\n            return allegedProto;\n        },\n\n        /**\n         * If target is non-extensible and setPrototypeOf trap returns true,\n         * check whether the trap result corresponds to the target's [[Prototype]]\n         */\n        setPrototypeOf: function(newProto) {\n            var trap = this.getTrap(\"setPrototypeOf\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.setPrototypeOf(this.target, newProto);\n            }\n\n            var success = trap.call(this.handler, this.target, newProto);\n\n            success = !!success;\n            if (success && !Object_isExtensible(this.target)) {\n                var actualProto = Object_getPrototypeOf(this.target);\n                if (!sameValue(newProto, actualProto)) {\n                    throw new TypeError(\"prototype value does not match: \" + this.target);\n                }\n            }\n\n            return success;\n        },\n\n        /**\n         * In the direct proxies design with refactored prototype climbing,\n         * this trap is deprecated. For proxies-as-prototypes, for-in will\n         * call the enumerate() trap. If that trap is not defined, the\n         * operation is forwarded to the target, no more fallback on this\n         * fundamental trap.\n         */\n        getPropertyNames: function() {\n            throw new TypeError(\"getPropertyNames trap is deprecated\");\n        },\n\n        // === derived traps ===\n\n        /**\n         * If name denotes a fixed property, check whether the trap returns true.\n         */\n        has: function(name) {\n            var trap = this.getTrap(\"has\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.has(this.target, name);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name);\n            res = !!res; // coerce to Boolean\n\n            if (res === false) {\n                if (isSealed(name, this.target)) {\n                    throw new TypeError(\"cannot report existing non-configurable own \"+\n                        \"property '\"+ name + \"' as a non-existent \"+\n                        \"property\");\n                }\n                if (!Object.isExtensible(this.target) &&\n                    isFixed(name, this.target)) {\n                    // if handler is allowed to return false, we cannot guarantee\n                    // that it will not return true for this property later.\n                    // Once a property has been reported as non-existent on a non-extensible\n                    // object, it should forever be reported as non-existent\n                    throw new TypeError(\"cannot report existing own property '\"+name+\n                        \"' as non-existent on a non-extensible object\");\n                }\n            }\n\n            // if res === true, we don't need to check for extensibility\n            // even for a non-extensible proxy that has no own name property,\n            // the property may have been inherited\n\n            return res;\n        },\n\n        /**\n         * If name denotes a fixed non-configurable, non-writable data property,\n         * check its return value against the previously asserted value of the\n         * fixed property.\n         */\n        get: function(receiver, name) {\n\n            // experimental support for invoke() trap on platforms that\n            // support __noSuchMethod__\n            /*\n             if (name === '__noSuchMethod__') {\n             var handler = this;\n             return function(name, args) {\n             return handler.invoke(receiver, name, args);\n             }\n             }\n             */\n\n            var trap = this.getTrap(\"get\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.get(this.target, name, receiver);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name, receiver);\n\n            var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n            // check consistency of the returned value\n            if (fixedDesc !== undefined) { // getting an existing property\n                if (isDataDescriptor(fixedDesc) &&\n                    fixedDesc.configurable === false &&\n                    fixedDesc.writable === false) { // own frozen data property\n                    if (!sameValue(res, fixedDesc.value)) {\n                        throw new TypeError(\"cannot report inconsistent value for \"+\n                            \"non-writable, non-configurable property '\"+\n                            name+\"'\");\n                    }\n                } else { // it's an accessor property\n                    if (isAccessorDescriptor(fixedDesc) &&\n                        fixedDesc.configurable === false &&\n                        fixedDesc.get === undefined) {\n                        if (res !== undefined) {\n                            throw new TypeError(\"must report undefined for non-configurable \"+\n                                \"accessor property '\"+name+\"' without getter\");\n                        }\n                    }\n                }\n            }\n\n            return res;\n        },\n\n        /**\n         * If name denotes a fixed non-configurable, non-writable data property,\n         * check that the trap rejects the assignment.\n         */\n        set: function(receiver, name, val) {\n            var trap = this.getTrap(\"set\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.set(this.target, name, val, receiver);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name, val, receiver);\n            res = !!res; // coerce to Boolean\n\n            // if success is reported, check whether property is truly assignable\n            if (res === true) {\n                var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                if (fixedDesc !== undefined) { // setting an existing property\n                    if (isDataDescriptor(fixedDesc) &&\n                        fixedDesc.configurable === false &&\n                        fixedDesc.writable === false) {\n                        if (!sameValue(val, fixedDesc.value)) {\n                            throw new TypeError(\"cannot successfully assign to a \"+\n                                \"non-writable, non-configurable property '\"+\n                                name+\"'\");\n                        }\n                    } else {\n                        if (isAccessorDescriptor(fixedDesc) &&\n                            fixedDesc.configurable === false && // non-configurable\n                            fixedDesc.set === undefined) {      // accessor with undefined setter\n                            throw new TypeError(\"setting a property '\"+name+\"' that has \"+\n                                \" only a getter\");\n                        }\n                    }\n                }\n            }\n\n            return res;\n        },\n\n        /**\n         * Any own enumerable non-configurable properties of the target that are not\n         * included in the trap result give rise to a TypeError. As such, we check\n         * whether the returned result contains at least all sealed enumerable properties\n         * of the target object.\n         *\n         * The trap should return an iterator.\n         *\n         * However, as implementations of pre-direct proxies still expect enumerate\n         * to return an array of strings, we convert the iterator into an array.\n         */\n        enumerate: function() {\n            var trap = this.getTrap(\"enumerate\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                var trapResult = Reflect.enumerate(this.target);\n                var result = [];\n                var nxt = trapResult.next();\n                while (!nxt.done) {\n                    result.push(String(nxt.value));\n                    nxt = trapResult.next();\n                }\n                return result;\n            }\n\n            var trapResult = trap.call(this.handler, this.target);\n\n            if (trapResult === null ||\n                trapResult === undefined ||\n                trapResult.next === undefined) {\n                throw new TypeError(\"enumerate trap should return an iterator, got: \"+\n                    trapResult);\n            }\n\n            // propNames is used as a set of strings\n            var propNames = Object.create(null);\n\n            // var numProps = +trapResult.length;\n            var result = []; // new Array(numProps);\n\n            // trapResult is supposed to be an iterator\n            // drain iterator to array as current implementations still expect\n            // enumerate to return an array of strings\n            var nxt = trapResult.next();\n\n            while (!nxt.done) {\n                var s = String(nxt.value);\n                if (propNames[s]) {\n                    throw new TypeError(\"enumerate trap cannot list a \"+\n                        \"duplicate property '\"+s+\"'\");\n                }\n                propNames[s] = true;\n                result.push(s);\n                nxt = trapResult.next();\n            }\n\n            /*for (var i = 0; i < numProps; i++) {\n             var s = String(trapResult[i]);\n             if (propNames[s]) {\n             throw new TypeError(\"enumerate trap cannot list a \"+\n             \"duplicate property '\"+s+\"'\");\n             }\n             propNames[s] = true;\n             result[i] = s;\n             } */\n\n            var ownEnumerableProps = Object.keys(this.target);\n            var target = this.target;\n            ownEnumerableProps.forEach(function (ownEnumerableProp) {\n                if (!propNames[ownEnumerableProp]) {\n                    if (isSealed(ownEnumerableProp, target)) {\n                        throw new TypeError(\"enumerate trap failed to include \"+\n                            \"non-configurable enumerable property '\"+\n                            ownEnumerableProp+\"'\");\n                    }\n                    if (!Object.isExtensible(target) &&\n                        isFixed(ownEnumerableProp, target)) {\n                        // if handler is allowed not to report ownEnumerableProp as an own\n                        // property, we cannot guarantee that it will never report it as\n                        // an own property later. Once a property has been reported as\n                        // non-existent on a non-extensible object, it should forever be\n                        // reported as non-existent\n                        throw new TypeError(\"cannot report existing own property '\"+\n                            ownEnumerableProp+\"' as non-existent on a \"+\n                            \"non-extensible object\");\n                    }\n                }\n            });\n\n            return result;\n        },\n\n        /**\n         * The iterate trap is deprecated by the enumerate trap.\n         */\n        iterate: Validator.prototype.enumerate,\n\n        /**\n         * Any own non-configurable properties of the target that are not included\n         * in the trap result give rise to a TypeError. As such, we check whether the\n         * returned result contains at least all sealed properties of the target\n         * object.\n         *\n         * The trap result is normalized.\n         * The trap result is not returned directly. Instead:\n         *  - create and return a fresh Array,\n         *  - of which each element is coerced to String,\n         *  - which does not contain duplicates\n         *\n         * FIXME: keys trap is deprecated\n         */\n        /*\n         keys: function() {\n         var trap = this.getTrap(\"keys\");\n         if (trap === undefined) {\n         // default forwarding behavior\n         return Reflect.keys(this.target);\n         }\n         var trapResult = trap.call(this.handler, this.target);\n         // propNames is used as a set of strings\n         var propNames = Object.create(null);\n         var numProps = +trapResult.length;\n         var result = new Array(numProps);\n         for (var i = 0; i < numProps; i++) {\n         var s = String(trapResult[i]);\n         if (propNames[s]) {\n         throw new TypeError(\"keys trap cannot list a \"+\n         \"duplicate property '\"+s+\"'\");\n         }\n         if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n         // non-extensible proxies don't tolerate new own property names\n         throw new TypeError(\"keys trap cannot list a new \"+\n         \"property '\"+s+\"' on a non-extensible object\");\n         }\n         propNames[s] = true;\n         result[i] = s;\n         }\n         var ownEnumerableProps = Object.keys(this.target);\n         var target = this.target;\n         ownEnumerableProps.forEach(function (ownEnumerableProp) {\n         if (!propNames[ownEnumerableProp]) {\n         if (isSealed(ownEnumerableProp, target)) {\n         throw new TypeError(\"keys trap failed to include \"+\n         \"non-configurable enumerable property '\"+\n         ownEnumerableProp+\"'\");\n         }\n         if (!Object.isExtensible(target) &&\n         isFixed(ownEnumerableProp, target)) {\n         // if handler is allowed not to report ownEnumerableProp as an own\n         // property, we cannot guarantee that it will never report it as\n         // an own property later. Once a property has been reported as\n         // non-existent on a non-extensible object, it should forever be\n         // reported as non-existent\n         throw new TypeError(\"cannot report existing own property '\"+\n         ownEnumerableProp+\"' as non-existent on a \"+\n         \"non-extensible object\");\n         }\n         }\n         });\n         return result;\n         },\n         */\n\n        /**\n         * New trap that reifies [[Call]].\n         * If the target is a function, then a call to\n         *   proxy(...args)\n         * Triggers this trap\n         */\n        apply: function(target, thisBinding, args) {\n            var trap = this.getTrap(\"apply\");\n            if (trap === undefined) {\n                return Reflect.apply(target, thisBinding, args);\n            }\n\n            if (typeof this.target === \"function\") {\n                return trap.call(this.handler, target, thisBinding, args);\n            } else {\n                throw new TypeError(\"apply: \"+ target + \" is not a function\");\n            }\n        },\n\n        /**\n         * New trap that reifies [[Construct]].\n         * If the target is a function, then a call to\n         *   new proxy(...args)\n         * Triggers this trap\n         */\n        construct: function(target, args, newTarget) {\n            var trap = this.getTrap(\"construct\");\n            if (trap === undefined) {\n                return Reflect.construct(target, args, newTarget);\n            }\n\n            if (typeof target !== \"function\") {\n                throw new TypeError(\"new: \"+ target + \" is not a function\");\n            }\n\n            if (newTarget === undefined) {\n                newTarget = target;\n            } else {\n                if (typeof newTarget !== \"function\") {\n                    throw new TypeError(\"new: \"+ newTarget + \" is not a function\");\n                }\n            }\n            return trap.call(this.handler, target, args, newTarget);\n        }\n    };\n\n// ---- end of the Validator handler wrapper handler ----\n\n// In what follows, a 'direct proxy' is a proxy\n// whose handler is a Validator. Such proxies can be made non-extensible,\n// sealed or frozen without losing the ability to trap.\n\n// maps direct proxies to their Validator handlers\n    var directProxies = new WeakMap();\n\n// patch Object.{preventExtensions,seal,freeze} so that\n// they recognize fixable proxies and act accordingly\n    Object.preventExtensions = function(subject) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            if (vhandler.preventExtensions()) {\n                return subject;\n            } else {\n                throw new TypeError(\"preventExtensions on \"+subject+\" rejected\");\n            }\n        } else {\n            return prim_preventExtensions(subject);\n        }\n    };\n    Object.seal = function(subject) {\n        setIntegrityLevel(subject, \"sealed\");\n        return subject;\n    };\n    Object.freeze = function(subject) {\n        setIntegrityLevel(subject, \"frozen\");\n        return subject;\n    };\n    Object.isExtensible = Object_isExtensible = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.isExtensible();\n        } else {\n            return prim_isExtensible(subject);\n        }\n    };\n    Object.isSealed = Object_isSealed = function(subject) {\n        return testIntegrityLevel(subject, \"sealed\");\n    };\n    Object.isFrozen = Object_isFrozen = function(subject) {\n        return testIntegrityLevel(subject, \"frozen\");\n    };\n    Object.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.getPrototypeOf();\n        } else {\n            return prim_getPrototypeOf(subject);\n        }\n    };\n\n// patch Object.getOwnPropertyDescriptor to directly call\n// the Validator.prototype.getOwnPropertyDescriptor trap\n// This is to circumvent an assertion in the built-in Proxy\n// trapping mechanism of v8, which disallows that trap to\n// return non-configurable property descriptors (as per the\n// old Proxy design)\n    Object.getOwnPropertyDescriptor = function(subject, name) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            return vhandler.getOwnPropertyDescriptor(name);\n        } else {\n            return prim_getOwnPropertyDescriptor(subject, name);\n        }\n    };\n\n// patch Object.defineProperty to directly call\n// the Validator.prototype.defineProperty trap\n// This is to circumvent two issues with the built-in\n// trap mechanism:\n// 1) the current tracemonkey implementation of proxies\n// auto-completes 'desc', which is not correct. 'desc' should be\n// normalized, but not completed. Consider:\n// Object.defineProperty(proxy, 'foo', {enumerable:false})\n// This trap will receive desc =\n//  {value:undefined,writable:false,enumerable:false,configurable:false}\n// This will also set all other attributes to their default value,\n// which is unexpected and different from [[DefineOwnProperty]].\n// Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n// 2) the current spidermonkey implementation does not\n// throw an exception when this trap returns 'false', but instead silently\n// ignores the operation (this is regardless of strict-mode)\n// 2a) v8 does throw an exception for this case, but includes the rather\n//     unhelpful error message:\n// 'Proxy handler #<Object> returned false from 'defineProperty' trap'\n    Object.defineProperty = function(subject, name, desc) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            var normalizedDesc = normalizePropertyDescriptor(desc);\n            var success = vhandler.defineProperty(name, normalizedDesc);\n            if (success === false) {\n                throw new TypeError(\"can't redefine property '\"+name+\"'\");\n            }\n            return subject;\n        } else {\n            return prim_defineProperty(subject, name, desc);\n        }\n    };\n\n    Object.defineProperties = function(subject, descs) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            var names = Object.keys(descs);\n            for (var i = 0; i < names.length; i++) {\n                var name = names[i];\n                var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n                var success = vhandler.defineProperty(name, normalizedDesc);\n                if (success === false) {\n                    throw new TypeError(\"can't redefine property '\"+name+\"'\");\n                }\n            }\n            return subject;\n        } else {\n            return prim_defineProperties(subject, descs);\n        }\n    };\n\n    Object.keys = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            var ownKeys = vHandler.ownKeys();\n            var result = [];\n            for (var i = 0; i < ownKeys.length; i++) {\n                var k = String(ownKeys[i]);\n                var desc = Object.getOwnPropertyDescriptor(subject, k);\n                if (desc !== undefined && desc.enumerable === true) {\n                    result.push(k);\n                }\n            }\n            return result;\n        } else {\n            return prim_keys(subject);\n        }\n    }\n\n    Object.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.ownKeys();\n        } else {\n            return prim_getOwnPropertyNames(subject);\n        }\n    }\n\n// fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n// throws an error)\n    if (prim_getOwnPropertySymbols !== undefined) {\n        Object.getOwnPropertySymbols = function(subject) {\n            var vHandler = directProxies.get(subject);\n            if (vHandler !== undefined) {\n                // as this shim does not support symbols, a Proxy never advertises\n                // any symbol-valued own properties\n                return [];\n            } else {\n                return prim_getOwnPropertySymbols(subject);\n            }\n        };\n    }\n\n// fixes issue #72 ('Illegal access' error when using Object.assign)\n// Object.assign polyfill based on a polyfill posted on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n//  Global_Objects/Object/assign\n// Note that this polyfill does not support Symbols, but this Proxy Shim\n// does not support Symbols anyway.\n    if (prim_assign !== undefined) {\n        Object.assign = function (target) {\n\n            // check if any argument is a proxy object\n            var noProxies = true;\n            for (var i = 0; i < arguments.length; i++) {\n                var vHandler = directProxies.get(arguments[i]);\n                if (vHandler !== undefined) {\n                    noProxies = false;\n                    break;\n                }\n            }\n            if (noProxies) {\n                // not a single argument is a proxy, perform built-in algorithm\n                return prim_assign.apply(Object, arguments);\n            }\n\n            // there is at least one proxy argument, use the polyfill\n\n            if (target === undefined || target === null) {\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var output = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for (var nextKey in source) {\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    }\n\n// returns whether an argument is a reference to an object,\n// which is legal as a WeakMap key.\n    function isObject(arg) {\n        var type = typeof arg;\n        return (type === 'object' && arg !== null) || (type === 'function');\n    };\n\n// a wrapper for WeakMap.get which returns the undefined value\n// for keys that are not objects (in which case the underlying\n// WeakMap would have thrown a TypeError).\n    function safeWeakMapGet(map, key) {\n        return isObject(key) ? map.get(key) : undefined;\n    };\n\n// returns a new function of zero arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a zero-argument method\n// that uses its |this|-binding.\n    function makeUnwrapping0ArgMethod(primitive) {\n        return function builtin() {\n            var vHandler = safeWeakMapGet(directProxies, this);\n            if (vHandler !== undefined) {\n                return builtin.call(vHandler.target);\n            } else {\n                return primitive.call(this);\n            }\n        }\n    };\n\n// returns a new function of 1 arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a 1-argument method\n// that uses its |this|-binding.\n    function makeUnwrapping1ArgMethod(primitive) {\n        return function builtin(arg) {\n            var vHandler = safeWeakMapGet(directProxies, this);\n            if (vHandler !== undefined) {\n                return builtin.call(vHandler.target, arg);\n            } else {\n                return primitive.call(this, arg);\n            }\n        }\n    };\n\n    Object.prototype.valueOf =\n        makeUnwrapping0ArgMethod(Object.prototype.valueOf);\n    Object.prototype.toString =\n        makeUnwrapping0ArgMethod(Object.prototype.toString);\n    Function.prototype.toString =\n        makeUnwrapping0ArgMethod(Function.prototype.toString);\n    Date.prototype.toString =\n        makeUnwrapping0ArgMethod(Date.prototype.toString);\n\n    Object.prototype.isPrototypeOf = function builtin(arg) {\n        // bugfix thanks to Bill Mark:\n        // built-in isPrototypeOf does not unwrap proxies used\n        // as arguments. So, we implement the builtin ourselves,\n        // based on the ECMAScript 6 spec. Our encoding will\n        // make sure that if a proxy is used as an argument,\n        // its getPrototypeOf trap will be called.\n        while (true) {\n            var vHandler2 = safeWeakMapGet(directProxies, arg);\n            if (vHandler2 !== undefined) {\n                arg = vHandler2.getPrototypeOf();\n                if (arg === null) {\n                    return false;\n                } else if (sameValue(arg, this)) {\n                    return true;\n                }\n            } else {\n                return prim_isPrototypeOf.call(this, arg);\n            }\n        }\n    };\n\n    Array.isArray = function(subject) {\n        var vHandler = safeWeakMapGet(directProxies, subject);\n        if (vHandler !== undefined) {\n            return Array.isArray(vHandler.target);\n        } else {\n            return prim_isArray(subject);\n        }\n    };\n\n    function isProxyArray(arg) {\n        var vHandler = safeWeakMapGet(directProxies, arg);\n        if (vHandler !== undefined) {\n            return Array.isArray(vHandler.target);\n        }\n        return false;\n    }\n\n// Array.prototype.concat internally tests whether one of its\n// arguments is an Array, by checking whether [[Class]] == \"Array\"\n// As such, it will fail to recognize proxies-for-arrays as arrays.\n// We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n// by making a copy. This will trigger the exact same sequence of\n// traps on the proxy-for-array as if we would not have unwrapped it.\n// See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\n    Array.prototype.concat = function(/*...args*/) {\n        var length;\n        for (var i = 0; i < arguments.length; i++) {\n            if (isProxyArray(arguments[i])) {\n                length = arguments[i].length;\n                arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n            }\n        }\n        return prim_concat.apply(this, arguments);\n    };\n\n// setPrototypeOf support on platforms that support __proto__\n\n    var prim_setPrototypeOf = Object.setPrototypeOf;\n\n// patch and extract original __proto__ setter\n    var __proto__setter = (function() {\n        var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype,'__proto__');\n        if (protoDesc === undefined ||\n            typeof protoDesc.set !== \"function\") {\n            return function() {\n                throw new TypeError(\"setPrototypeOf not supported on this platform\");\n            }\n        }\n\n        // see if we can actually mutate a prototype with the generic setter\n        // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n        try {\n            protoDesc.set.call({},{});\n        } catch (e) {\n            return function() {\n                throw new TypeError(\"setPrototypeOf not supported on this platform\");\n            }\n        }\n\n        prim_defineProperty(Object.prototype, '__proto__', {\n            set: function(newProto) {\n                return Object.setPrototypeOf(this, Object(newProto));\n            }\n        });\n\n        return protoDesc.set;\n    }());\n\n    Object.setPrototypeOf = function(target, newProto) {\n        var handler = directProxies.get(target);\n        if (handler !== undefined) {\n            if (handler.setPrototypeOf(newProto)) {\n                return target;\n            } else {\n                throw new TypeError(\"proxy rejected prototype mutation\");\n            }\n        } else {\n            if (!Object_isExtensible(target)) {\n                throw new TypeError(\"can't set prototype on non-extensible object: \" +\n                    target);\n            }\n            if (prim_setPrototypeOf)\n                return prim_setPrototypeOf(target, newProto);\n\n            if (Object(newProto) !== newProto || newProto === null) {\n                throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                    newProto);\n                // throw new TypeError(\"prototype must be an object or null\")\n            }\n            __proto__setter.call(target, newProto);\n            return target;\n        }\n    }\n\n    Object.prototype.hasOwnProperty = function(name) {\n        var handler = safeWeakMapGet(directProxies, this);\n        if (handler !== undefined) {\n            var desc = handler.getOwnPropertyDescriptor(name);\n            return desc !== undefined;\n        } else {\n            return prim_hasOwnProperty.call(this, name);\n        }\n    }\n\n// ============= Reflection module =============\n// see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\n    var Reflect = global.Reflect = {\n        getOwnPropertyDescriptor: function(target, name) {\n            return Object.getOwnPropertyDescriptor(target, name);\n        },\n        defineProperty: function(target, name, desc) {\n\n            // if target is a proxy, invoke its \"defineProperty\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.defineProperty(target, name, desc);\n            }\n\n            // Implementation transliterated from [[DefineOwnProperty]]\n            // see ES5.1 section 8.12.9\n            // this is the _exact same algorithm_ as the isCompatibleDescriptor\n            // algorithm defined above, except that at every place it\n            // returns true, this algorithm actually does define the property.\n            var current = Object.getOwnPropertyDescriptor(target, name);\n            var extensible = Object.isExtensible(target);\n            if (current === undefined && extensible === false) {\n                return false;\n            }\n            if (current === undefined && extensible === true) {\n                Object.defineProperty(target, name, desc); // should never fail\n                return true;\n            }\n            if (isEmptyDescriptor(desc)) {\n                return true;\n            }\n            if (isEquivalentDescriptor(current, desc)) {\n                return true;\n            }\n            if (current.configurable === false) {\n                if (desc.configurable === true) {\n                    return false;\n                }\n                if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n                    return false;\n                }\n            }\n            if (isGenericDescriptor(desc)) {\n                // no further validation necessary\n            } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n                if (current.configurable === false) {\n                    return false;\n                }\n            } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n                if (current.configurable === false) {\n                    if (current.writable === false && desc.writable === true) {\n                        return false;\n                    }\n                    if (current.writable === false) {\n                        if ('value' in desc && !sameValue(desc.value, current.value)) {\n                            return false;\n                        }\n                    }\n                }\n            } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n                if (current.configurable === false) {\n                    if ('set' in desc && !sameValue(desc.set, current.set)) {\n                        return false;\n                    }\n                    if ('get' in desc && !sameValue(desc.get, current.get)) {\n                        return false;\n                    }\n                }\n            }\n            Object.defineProperty(target, name, desc); // should never fail\n            return true;\n        },\n        deleteProperty: function(target, name) {\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.delete(name);\n            }\n\n            var desc = Object.getOwnPropertyDescriptor(target, name);\n            if (desc === undefined) {\n                return true;\n            }\n            if (desc.configurable === true) {\n                delete target[name];\n                return true;\n            }\n            return false;\n        },\n        getPrototypeOf: function(target) {\n            return Object.getPrototypeOf(target);\n        },\n        setPrototypeOf: function(target, newProto) {\n\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.setPrototypeOf(newProto);\n            }\n\n            if (Object(newProto) !== newProto || newProto === null) {\n                throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                    newProto);\n            }\n\n            if (!Object_isExtensible(target)) {\n                return false;\n            }\n\n            var current = Object.getPrototypeOf(target);\n            if (sameValue(current, newProto)) {\n                return true;\n            }\n\n            if (prim_setPrototypeOf) {\n                try {\n                    prim_setPrototypeOf(target, newProto);\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n\n            __proto__setter.call(target, newProto);\n            return true;\n        },\n        preventExtensions: function(target) {\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.preventExtensions();\n            }\n            prim_preventExtensions(target);\n            return true;\n        },\n        isExtensible: function(target) {\n            return Object.isExtensible(target);\n        },\n        has: function(target, name) {\n            return name in target;\n        },\n        get: function(target, name, receiver) {\n            receiver = receiver || target;\n\n            // if target is a proxy, invoke its \"get\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.get(receiver, name);\n            }\n\n            var desc = Object.getOwnPropertyDescriptor(target, name);\n            if (desc === undefined) {\n                var proto = Object.getPrototypeOf(target);\n                if (proto === null) {\n                    return undefined;\n                }\n                return Reflect.get(proto, name, receiver);\n            }\n            if (isDataDescriptor(desc)) {\n                return desc.value;\n            }\n            var getter = desc.get;\n            if (getter === undefined) {\n                return undefined;\n            }\n            return desc.get.call(receiver);\n        },\n        // Reflect.set implementation based on latest version of [[SetP]] at\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n        set: function(target, name, value, receiver) {\n            receiver = receiver || target;\n\n            // if target is a proxy, invoke its \"set\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.set(receiver, name, value);\n            }\n\n            // first, check whether target has a non-writable property\n            // shadowing name on receiver\n            var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n            if (ownDesc === undefined) {\n                // name is not defined in target, search target's prototype\n                var proto = Object.getPrototypeOf(target);\n\n                if (proto !== null) {\n                    // continue the search in target's prototype\n                    return Reflect.set(proto, name, value, receiver);\n                }\n\n                // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n                // target was the last prototype, now we know that 'name' is not shadowed\n                // by an existing (accessor or data) property, so we can add the property\n                // to the initial receiver object\n                // (this branch will intentionally fall through to the code below)\n                ownDesc =\n                { value: undefined,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true };\n            }\n\n            // we now know that ownDesc !== undefined\n            if (isAccessorDescriptor(ownDesc)) {\n                var setter = ownDesc.set;\n                if (setter === undefined) return false;\n                setter.call(receiver, value); // assumes Function.prototype.call\n                return true;\n            }\n            // otherwise, isDataDescriptor(ownDesc) must be true\n            if (ownDesc.writable === false) return false;\n            // we found an existing writable data property on the prototype chain.\n            // Now update or add the data property on the receiver, depending on\n            // whether the receiver already defines the property or not.\n            var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n            if (existingDesc !== undefined) {\n                var updateDesc =\n                { value: value,\n                    // FIXME: it should not be necessary to describe the following\n                    // attributes. Added to circumvent a bug in tracemonkey:\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n                    writable:     existingDesc.writable,\n                    enumerable:   existingDesc.enumerable,\n                    configurable: existingDesc.configurable };\n                Object.defineProperty(receiver, name, updateDesc);\n                return true;\n            } else {\n                if (!Object.isExtensible(receiver)) return false;\n                var newDesc =\n                { value: value,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true };\n                Object.defineProperty(receiver, name, newDesc);\n                return true;\n            }\n        },\n        /*invoke: function(target, name, args, receiver) {\n         receiver = receiver || target;\n         var handler = directProxies.get(target);\n         if (handler !== undefined) {\n         return handler.invoke(receiver, name, args);\n         }\n         var fun = Reflect.get(target, name, receiver);\n         return Function.prototype.apply.call(fun, receiver, args);\n         },*/\n        enumerate: function(target) {\n            var handler = directProxies.get(target);\n            var result;\n            if (handler !== undefined) {\n                // handler.enumerate should return an iterator directly, but the\n                // iterator gets converted to an array for backward-compat reasons,\n                // so we must re-iterate over the array\n                result = handler.enumerate(handler.target);\n            } else {\n                result = [];\n                for (var name in target) { result.push(name); };\n            }\n            var l = +result.length;\n            var idx = 0;\n            return {\n                next: function() {\n                    if (idx === l) return { done: true };\n                    return { done: false, value: result[idx++] };\n                }\n            };\n        },\n        // imperfect ownKeys implementation: in ES6, should also include\n        // symbol-keyed properties.\n        ownKeys: function(target) {\n            return Object_getOwnPropertyNames(target);\n        },\n        apply: function(target, receiver, args) {\n            // target.apply(receiver, args)\n            return Function.prototype.apply.call(target, receiver, args);\n        },\n        construct: function(target, args, newTarget) {\n            // return new target(...args);\n\n            // if target is a proxy, invoke its \"construct\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.construct(handler.target, args, newTarget);\n            }\n\n            if (typeof target !== \"function\") {\n                throw new TypeError(\"target is not a function: \" + target);\n            }\n            if (newTarget === undefined) {\n                newTarget = target;\n            } else {\n                if (typeof newTarget !== \"function\") {\n                    throw new TypeError(\"newTarget is not a function: \" + target);\n                }\n            }\n\n            return new (Function.prototype.bind.apply(newTarget, [null].concat(args)));\n        }\n    };\n\n// feature-test whether the Proxy global exists, with\n// the harmony-era Proxy.create API\n    if (typeof Proxy !== \"undefined\" &&\n        typeof Proxy.create !== \"undefined\") {\n\n        var primCreate = Proxy.create,\n            primCreateFunction = Proxy.createFunction;\n\n        var revokedHandler = primCreate({\n            get: function() { throw new TypeError(\"proxy is revoked\"); }\n        });\n\n        global.Proxy = function(target, handler) {\n            // check that target is an Object\n            if (Object(target) !== target) {\n                throw new TypeError(\"Proxy target must be an Object, given \"+target);\n            }\n            // check that handler is an Object\n            if (Object(handler) !== handler) {\n                throw new TypeError(\"Proxy handler must be an Object, given \"+handler);\n            }\n\n            var vHandler = new Validator(target, handler);\n            var proxy;\n            if (typeof target === \"function\") {\n                proxy = primCreateFunction(vHandler,\n                    // call trap\n                    function() {\n                        var args = Array.prototype.slice.call(arguments);\n                        return vHandler.apply(target, this, args);\n                    },\n                    // construct trap\n                    function() {\n                        var args = Array.prototype.slice.call(arguments);\n                        return vHandler.construct(target, args);\n                    });\n            } else {\n                proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n            }\n            directProxies.set(proxy, vHandler);\n            return proxy;\n        };\n\n        global.Proxy.revocable = function(target, handler) {\n            var proxy = new Proxy(target, handler);\n            var revoke = function() {\n                var vHandler = directProxies.get(proxy);\n                if (vHandler !== null) {\n                    vHandler.target  = null;\n                    vHandler.handler = revokedHandler;\n                }\n                return undefined;\n            };\n            return {proxy: proxy, revoke: revoke};\n        }\n\n        // add the old Proxy.create and Proxy.createFunction methods\n        // so old code that still depends on the harmony-era Proxy object\n        // is not broken. Also ensures that multiple versions of this\n        // library should load fine\n        global.Proxy.create = primCreate;\n        global.Proxy.createFunction = primCreateFunction;\n\n    } else {\n        // Proxy global not defined, or old API not available\n        if (typeof Proxy === \"undefined\") {\n            // Proxy global not defined, add a Proxy function stub\n            global.Proxy = function(_target, _handler) {\n                throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n            };\n        }\n        // Proxy global defined but old API not available\n        // presumably Proxy global already supports new API, leave untouched\n    }\n\n// for node.js modules, export every property in the Reflect object\n// as part of the module interface\n    if (typeof exports !== 'undefined') {\n        Object.keys(Reflect).forEach(function (key) {\n            exports[key] = Reflect[key];\n        });\n    }\n\n// function-as-module pattern\n}(typeof exports !== 'undefined' ? global : this));\n\n\n/**\n * Returns an object which allows for safe navigation of properties.\n * When raw property values are needed, simply execute the property as a function.\n *\n * e.g.\n * let nnObject = nn({ a: 1 });\n * nnObject.a() == 1\n * nnObject.non.existent.property.access() == undefined\n *\n * @param rawValue - object to be wrapped.\n * @returns {Proxy}\n */\nconst nn = (rawValue)=>{\n\n    //Each property accessed on a nevernull function-object will be this function.\n    //e.g. nn({}).prop1 is a function, which when executed, returns the passed in rawValue.\n    let wrappedValue = ()=>{\n        return rawValue;\n    };\n\n    //intercept all property access on the wrappedValue function-object\n    return new Proxy(wrappedValue, {\n\n        /**\n         * When a property is accessed, this function intercepts its access and instead returns a Proxy of a wrappedValue function.\n         * This allows us to do lazy recursion on all nested properties.\n         * @param target - object which is being asked for the property with the name of the 'name' parameter.\n         * @param name - property name on the target who's value is needed.\n         * @returns {Proxy} - recursive call to nevernull is returned so accessing nested properties is always safe.\n         */\n        get: function(target, name){\n            //get the raw target so we can access the raw property value.\n            let rawTarget = target();\n            let rawPropertyValue = rawTarget ? rawTarget[name] : undefined;\n\n            //function properties should maintain their context.\n            if(typeof rawPropertyValue === 'function'){\n                rawPropertyValue = rawPropertyValue.bind(rawTarget);\n            }\n\n            //ensure the property is never null.\n            return nn(rawPropertyValue);\n        }\n    });\n};\n"]}