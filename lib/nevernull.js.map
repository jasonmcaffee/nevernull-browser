{"version":3,"sources":["../src/nevernull.js"],"names":["scope","lastRevokeFn","isObject","o","Proxy","target","handler","TypeError","throwRevoked","trap","unsafeHandler","k","apply","bind","proxy","isMethod","targetIsFunction","usingNew","constructor","call","arguments","all","Array","prototype","slice","unshift","f","getter","get","prop","setter","set","value","status","propertyNames","Object","getOwnPropertyNames","propertyMap","forEach","real","getOwnPropertyDescriptor","desc","enumerable","defineProperty","prototypeOk","setPrototypeOf","getPrototypeOf","__proto__","seal","revocable","p","process","toString","global","self","nn","rawValue","wrappedValue","name","rawTarget","rawPropertyValue","undefined"],"mappings":"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","file":"nevernull.js","sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\n\n(function(scope) {\n    if (scope['Proxy']) {\n        return;\n    }\n    let lastRevokeFn = null;\n\n    /**\n     * @param {*} o\n     * @return {boolean} whether this is probably a (non-null) Object\n     */\n    function isObject(o) {\n        return o ? (typeof o == 'object' || typeof o == 'function') : false;\n    }\n\n    /**\n     * @constructor\n     * @param {!Object} target\n     * @param {{apply, construct, get, set}} handler\n     */\n    scope.Proxy = function(target, handler) {\n        if (!isObject(target) || !isObject(handler)) {\n            throw new TypeError('Cannot create proxy with a non-object as target or handler');\n        }\n\n        // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n        // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n        // to call itself, but that seems unlikely especially when using the polyfill.\n        let throwRevoked = function() {};\n        lastRevokeFn = function() {\n            throwRevoked = function(trap) {\n                throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n            };\n        };\n\n        // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n        // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n        let unsafeHandler = handler;\n        handler = {'get': null, 'set': null, 'apply': null, 'construct': null};\n        for (let k in unsafeHandler) {\n            if (!(k in handler)) {\n                throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n            }\n            handler[k] = unsafeHandler[k];\n        }\n        if (typeof unsafeHandler == 'function') {\n            // Allow handler to be a function (which has an 'apply' method). This matches what is\n            // probably a bug in native versions. It treats the apply call as a trap to be configured.\n            handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n        }\n\n        // Define proxy as this, or a Function (if either it's callable, or apply is set).\n        // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n        let proxy = this;\n        let isMethod = false;\n        let targetIsFunction = typeof target == 'function';\n        if (handler.apply || handler['construct'] || targetIsFunction) {\n            proxy = function Proxy() {\n                let usingNew = (this && this.constructor === proxy);\n                throwRevoked(usingNew ? 'construct' : 'apply');\n\n                if (usingNew && handler['construct']) {\n                    return handler['construct'].call(this, target, arguments);\n                } else if (!usingNew && handler.apply) {\n                    return handler.apply(target, this, arguments);\n                } else if (targetIsFunction) {\n                    // since the target was a function, fallback to calling it directly.\n                    if (usingNew) {\n                        // inspired by answers to https://stackoverflow.com/q/1606797\n                        let all = Array.prototype.slice.call(arguments);\n                        all.unshift(target);  // pass class as first arg to constructor, although irrelevant\n                        // nb. cast to convince Closure compiler that this is a constructor\n                        let f = /** @type {!Function} */ (target.bind.apply(target, all));\n                        return new f();\n                    }\n                    return target.apply(this, arguments);\n                }\n                throw new TypeError(usingNew ? 'not a constructor' : 'not a function');\n            };\n            isMethod = true;\n        }\n\n        // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n        // change after creation.\n        let getter = handler.get ? function(prop) {\n            throwRevoked('get');\n            return handler.get(this, prop, proxy);\n        } : function(prop) {\n            throwRevoked('get');\n            return this[prop];\n        };\n        let setter = handler.set ? function(prop, value) {\n            throwRevoked('set');\n            let status = handler.set(this, prop, value, proxy);\n            if (!status) {\n                // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n                // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n                // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n            }\n        } : function(prop, value) {\n            throwRevoked('set');\n            this[prop] = value;\n        };\n\n        // Clone direct properties (i.e., not part of a prototype).\n        let propertyNames = Object.getOwnPropertyNames(target);\n        let propertyMap = {};\n        propertyNames.forEach(function(prop) {\n            if (isMethod && prop in proxy) {\n                return;  // ignore properties already here, e.g. 'bind', 'prototype' etc\n            }\n            let real = Object.getOwnPropertyDescriptor(target, prop);\n            let desc = {\n                enumerable: !!real.enumerable,\n                get: getter.bind(target, prop),\n                set: setter.bind(target, prop),\n            };\n            Object.defineProperty(proxy, prop, desc);\n            propertyMap[prop] = true;\n        });\n\n        // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n        // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n        // An alternative here would be to _just_ clone methods to keep behavior consistent.\n        let prototypeOk = true;\n        if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(proxy, Object.getPrototypeOf(target));\n        } else if (proxy.__proto__) {\n            proxy.__proto__ = target.__proto__;\n        } else {\n            prototypeOk = false;\n        }\n        if (handler.get || !prototypeOk) {\n            for (let k in target) {\n                if (propertyMap[k]) {\n                    continue;\n                }\n                Object.defineProperty(proxy, k, {get: getter.bind(target, k)});\n            }\n        }\n\n        // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n        Object.seal(target);\n        Object.seal(proxy);\n\n        return proxy;  // nb. if isMethod is true, proxy != this\n    };\n\n    scope.Proxy.revocable = function(target, handler) {\n        let p = new scope.Proxy(target, handler);\n        return {'proxy': p, 'revoke': lastRevokeFn};\n    };\n\n    scope.Proxy['revocable'] = scope.Proxy.revocable;\n    scope['Proxy'] = scope.Proxy;\n})(typeof process !== 'undefined' && {}.toString.call(process) == '[object process]' ? global : self);\n\n\n/**\n * Returns an object which allows for safe navigation of properties.\n * When raw property values are needed, simply execute the property as a function.\n *\n * e.g.\n * let nnObject = nn({ a: 1 });\n * nnObject.a() == 1\n * nnObject.non.existent.property.access() == undefined\n *\n * @param rawValue - object to be wrapped.\n * @returns {Proxy}\n */\nconst nn = (rawValue)=>{\n\n    //Each property accessed on a nevernull function-object will be this function.\n    //e.g. nn({}).prop1 is a function, which when executed, returns the passed in rawValue.\n    let wrappedValue = ()=>{\n        return rawValue;\n    };\n\n    //intercept all property access on the wrappedValue function-object\n    return new Proxy(wrappedValue, {\n\n        /**\n         * When a property is accessed, this function intercepts its access and instead returns a Proxy of a wrappedValue function.\n         * This allows us to do lazy recursion on all nested properties.\n         * @param target - object which is being asked for the property with the name of the 'name' parameter.\n         * @param name - property name on the target who's value is needed.\n         * @returns {Proxy} - recursive call to nevernull is returned so accessing nested properties is always safe.\n         */\n        get: function(target, name){\n            //get the raw target so we can access the raw property value.\n            let rawTarget = target();\n            let rawPropertyValue = rawTarget ? rawTarget[name] : undefined;\n\n            //function properties should maintain their context.\n            if(typeof rawPropertyValue === 'function'){\n                rawPropertyValue = rawPropertyValue.bind(rawTarget);\n            }\n\n            //ensure the property is never null.\n            return nn(rawPropertyValue);\n        }\n    });\n};\n"]}