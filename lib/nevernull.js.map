{"version":3,"sources":["../src/nevernull.js"],"names":["global","WeakMap","prototype","get","k","undefined","set","v","Error","isStandardAttribute","name","test","toPropertyDescriptor","obj","Object","TypeError","desc","enumerable","configurable","value","writable","getter","setter","isAccessorDescriptor","isDataDescriptor","isGenericDescriptor","toCompletePropertyDescriptor","internalDesc","isEmptyDescriptor","isEquivalentDescriptor","desc1","desc2","sameValue","x","y","normalizeAndCompletePropertyDescriptor","attributes","defineProperty","normalizePropertyDescriptor","prim_preventExtensions","preventExtensions","prim_seal","seal","prim_freeze","freeze","prim_isExtensible","isExtensible","prim_isSealed","isSealed","prim_isFrozen","isFrozen","prim_getPrototypeOf","getPrototypeOf","prim_getOwnPropertyDescriptor","getOwnPropertyDescriptor","prim_defineProperty","prim_defineProperties","defineProperties","prim_keys","keys","prim_getOwnPropertyNames","getOwnPropertyNames","prim_getOwnPropertySymbols","getOwnPropertySymbols","prim_assign","assign","prim_isArray","Array","isArray","prim_concat","concat","prim_isPrototypeOf","isPrototypeOf","prim_hasOwnProperty","hasOwnProperty","Object_isFrozen","Object_isSealed","Object_isExtensible","Object_getPrototypeOf","Object_getOwnPropertyNames","isFixed","target","call","isSealedDesc","isCompatibleDescriptor","extensible","current","setIntegrityLevel","level","ownProps","pendingException","l","length","i","String","e","currentDesc","Reflect","testIntegrityLevel","Validator","handler","getTrap","trapName","trap","targetDesc","getPropertyDescriptor","has","val","descObj","success","delete","deleteProperty","res","ownKeys","trapResult","propNames","create","numProps","result","s","forEach","ownProp","state","allegedProto","actualProto","setPrototypeOf","newProto","getPropertyNames","receiver","fixedDesc","enumerate","nxt","next","done","push","ownEnumerableProps","ownEnumerableProp","iterate","apply","thisBinding","args","construct","newTarget","directProxies","subject","vhandler","vHandler","normalizedDesc","descs","names","noProxies","arguments","output","index","source","nextKey","isObject","arg","type","safeWeakMapGet","map","key","makeUnwrapping0ArgMethod","primitive","builtin","makeUnwrapping1ArgMethod","valueOf","toString","Function","Date","vHandler2","isProxyArray","slice","prim_setPrototypeOf","__proto__setter","protoDesc","proto","ownDesc","existingDesc","updateDesc","newDesc","idx","bind","Proxy","primCreate","primCreateFunction","createFunction","revokedHandler","proxy","revocable","revoke","_target","_handler","exports","window","nn","rawValue","wrappedValue","rawTarget","rawPropertyValue"],"mappings":"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","file":"nevernull.js","sourcesContent":["// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n// ----------------------------------------------------------------------------\n\n// This file is a polyfill for the upcoming ECMAScript Reflect API,\n// including support for Proxies. See the draft specification at:\n// http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// For an implementation of the Handler API, see handlers.js, which implements:\n// http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n// This implementation supersedes the earlier polyfill at:\n// code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n// This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n// The code also works correctly on\n//   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n// Language Dependencies:\n//  - ECMAScript 5/strict\n//  - \"old\" (i.e. non-direct) Harmony Proxies\n//  - Harmony WeakMaps\n// Patches:\n//  - Object.{freeze,seal,preventExtensions}\n//  - Object.{isFrozen,isSealed,isExtensible}\n//  - Object.getPrototypeOf\n//  - Object.keys\n//  - Object.prototype.valueOf\n//  - Object.prototype.isPrototypeOf\n//  - Object.prototype.toString\n//  - Object.prototype.hasOwnProperty\n//  - Object.getOwnPropertyDescriptor\n//  - Object.defineProperty\n//  - Object.defineProperties\n//  - Object.getOwnPropertyNames\n//  - Object.getOwnPropertySymbols\n//  - Object.getPrototypeOf\n//  - Object.setPrototypeOf\n//  - Object.assign\n//  - Function.prototype.toString\n//  - Date.prototype.toString\n//  - Array.isArray\n//  - Array.prototype.concat\n//  - Proxy\n// Adds new globals:\n//  - Reflect\n\n// Direct proxies can be created via Proxy(target, handler)\n\n// ----------------------------------------------------------------------------\n\n(function(global){ // function-as-module pattern\n    \"use strict\";\n\n// === Direct Proxies: Invariant Enforcement ===\n\n// Direct proxies build on non-direct proxies by automatically wrapping\n// all user-defined proxy handlers in a Validator handler that checks and\n// enforces ES5 invariants.\n\n// A direct proxy is a proxy for an existing object called the target object.\n\n// A Validator handler is a wrapper for a target proxy handler H.\n// The Validator forwards all operations to H, but additionally\n// performs a number of integrity checks on the results of some traps,\n// to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n// properties and non-extensible, sealed or frozen objects.\n\n// For each property that H exposes as own, non-configurable\n// (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n// the Validator handler defines those properties on the target object.\n// When the proxy becomes non-extensible, also configurable own properties\n// are checked against the target.\n// We will call properties that are defined on the target object\n// \"fixed properties\".\n\n// We will name fixed non-configurable properties \"sealed properties\".\n// We will name fixed non-configurable non-writable properties \"frozen\n// properties\".\n\n// The Validator handler upholds the following invariants w.r.t. non-configurability:\n// - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n// - getOwnPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property (e.g. reporting a non-configurable\n//   property as configurable, or reporting a non-configurable, non-writable\n//   property as writable)\n// - getPropertyDescriptor cannot report sealed properties as non-existent\n// - getPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property. It _can_ report incompatible changes\n//   to the attributes of non-own, inherited properties.\n// - defineProperty cannot make incompatible changes to the attributes of\n//   sealed properties\n// - deleteProperty cannot report a successful deletion of a sealed property\n// - hasOwn cannot report a sealed property as non-existent\n// - has cannot report a sealed property as non-existent\n// - get cannot report inconsistent values for frozen data\n//   properties, and must report undefined for sealed accessors with an\n//   undefined getter\n// - set cannot report a successful assignment for frozen data\n//   properties or sealed accessors with an undefined setter.\n// - get{Own}PropertyNames lists all sealed properties of the target.\n// - keys lists all enumerable sealed properties of the target.\n// - enumerate lists all enumerable sealed properties of the target.\n// - if a property of a non-extensible proxy is reported as non-existent,\n//   then it must forever be reported as non-existent. This applies to\n//   own and inherited properties and is enforced in the\n//   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n//   get{Own}PropertyNames, keys and enumerate traps\n\n// Violation of any of these invariants by H will result in TypeError being\n// thrown.\n\n// Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n// is invoked on the proxy, the set of own property names for the proxy is\n// fixed. Any property name that is not fixed is called a 'new' property.\n\n// The Validator upholds the following invariants regarding extensibility:\n// - getOwnPropertyDescriptor cannot report new properties as existent\n//   (it must report them as non-existent by returning undefined)\n// - defineProperty cannot successfully add a new property (it must reject)\n// - getOwnPropertyNames cannot list new properties\n// - hasOwn cannot report true for new properties (it must report false)\n// - keys cannot list new properties\n\n// Invariants currently not enforced:\n// - getOwnPropertyNames lists only own property names\n// - keys lists only enumerable own property names\n// Both traps may list more property names than are actually defined on the\n// target.\n\n// Invariants with regard to inheritance are currently not enforced.\n// - a non-configurable potentially inherited property on a proxy with\n//   non-mutable ancestry cannot be reported as non-existent\n// (An object with non-mutable ancestry is a non-extensible object whose\n// [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n// Changes in Handler API compared to previous harmony:proxies, see:\n// http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// ----------------------------------------------------------------------------\n\n// ---- WeakMap polyfill ----\n\n// TODO: find a proper WeakMap polyfill\n\n// define an empty WeakMap so that at least the Reflect module code\n// will work in the absence of WeakMaps. Proxy emulation depends on\n// actual WeakMaps, so will not work with this little shim.\n    if (typeof WeakMap === \"undefined\") {\n        global.WeakMap = function(){};\n        global.WeakMap.prototype = {\n            get: function(k) { return undefined; },\n            set: function(k,v) { throw new Error(\"WeakMap not supported\"); }\n        };\n    }\n\n// ---- Normalization functions for property descriptors ----\n\n    function isStandardAttribute(name) {\n        return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n    }\n\n// Adapted from ES5 section 8.10.5\n    function toPropertyDescriptor(obj) {\n        if (Object(obj) !== obj) {\n            throw new TypeError(\"property descriptor should be an Object, given: \"+\n                obj);\n        }\n        var desc = {};\n        if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n        if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n        if ('value' in obj) { desc.value = obj.value; }\n        if ('writable' in obj) { desc.writable = !!obj.writable; }\n        if ('get' in obj) {\n            var getter = obj.get;\n            if (getter !== undefined && typeof getter !== \"function\") {\n                throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                    \"callable or undefined, given: \"+getter);\n            }\n            desc.get = getter;\n        }\n        if ('set' in obj) {\n            var setter = obj.set;\n            if (setter !== undefined && typeof setter !== \"function\") {\n                throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                    \"callable or undefined, given: \"+setter);\n            }\n            desc.set = setter;\n        }\n        if ('get' in desc || 'set' in desc) {\n            if ('value' in desc || 'writable' in desc) {\n                throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                    \"accessor descriptor: \"+obj);\n            }\n        }\n        return desc;\n    }\n\n    function isAccessorDescriptor(desc) {\n        if (desc === undefined) return false;\n        return ('get' in desc || 'set' in desc);\n    }\n    function isDataDescriptor(desc) {\n        if (desc === undefined) return false;\n        return ('value' in desc || 'writable' in desc);\n    }\n    function isGenericDescriptor(desc) {\n        if (desc === undefined) return false;\n        return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n    }\n\n    function toCompletePropertyDescriptor(desc) {\n        var internalDesc = toPropertyDescriptor(desc);\n        if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n            if (!('value' in internalDesc)) { internalDesc.value = undefined; }\n            if (!('writable' in internalDesc)) { internalDesc.writable = false; }\n        } else {\n            if (!('get' in internalDesc)) { internalDesc.get = undefined; }\n            if (!('set' in internalDesc)) { internalDesc.set = undefined; }\n        }\n        if (!('enumerable' in internalDesc)) { internalDesc.enumerable = false; }\n        if (!('configurable' in internalDesc)) { internalDesc.configurable = false; }\n        return internalDesc;\n    }\n\n    function isEmptyDescriptor(desc) {\n        return !('get' in desc) &&\n            !('set' in desc) &&\n            !('value' in desc) &&\n            !('writable' in desc) &&\n            !('enumerable' in desc) &&\n            !('configurable' in desc);\n    }\n\n    function isEquivalentDescriptor(desc1, desc2) {\n        return sameValue(desc1.get, desc2.get) &&\n            sameValue(desc1.set, desc2.set) &&\n            sameValue(desc1.value, desc2.value) &&\n            sameValue(desc1.writable, desc2.writable) &&\n            sameValue(desc1.enumerable, desc2.enumerable) &&\n            sameValue(desc1.configurable, desc2.configurable);\n    }\n\n// copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\n    function sameValue(x, y) {\n        if (x === y) {\n            // 0 === -0, but they are not identical\n            return x !== 0 || 1 / x === 1 / y;\n        }\n\n        // NaN !== NaN, but they are identical.\n        // NaNs are the only non-reflexive value, i.e., if x !== x,\n        // then x is a NaN.\n        // isNaN is broken: it converts its argument to number, so\n        // isNaN(\"foo\") => true\n        return x !== x && y !== y;\n    }\n\n    /**\n     * Returns a fresh property descriptor that is guaranteed\n     * to be complete (i.e. contain all the standard attributes).\n     * Additionally, any non-standard enumerable properties of\n     * attributes are copied over to the fresh descriptor.\n     *\n     * If attributes is undefined, returns undefined.\n     *\n     * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n     */\n    function normalizeAndCompletePropertyDescriptor(attributes) {\n        if (attributes === undefined) { return undefined; }\n        var desc = toCompletePropertyDescriptor(attributes);\n        // Note: no need to call FromPropertyDescriptor(desc), as we represent\n        // \"internal\" property descriptors as proper Objects from the start\n        for (var name in attributes) {\n            if (!isStandardAttribute(name)) {\n                Object.defineProperty(desc, name,\n                    { value: attributes[name],\n                        writable: true,\n                        enumerable: true,\n                        configurable: true });\n            }\n        }\n        return desc;\n    }\n\n    /**\n     * Returns a fresh property descriptor whose standard\n     * attributes are guaranteed to be data properties of the right type.\n     * Additionally, any non-standard enumerable properties of\n     * attributes are copied over to the fresh descriptor.\n     *\n     * If attributes is undefined, will throw a TypeError.\n     *\n     * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n     */\n    function normalizePropertyDescriptor(attributes) {\n        var desc = toPropertyDescriptor(attributes);\n        // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n        // \"internal\" property descriptors as proper Objects from the start\n        for (var name in attributes) {\n            if (!isStandardAttribute(name)) {\n                Object.defineProperty(desc, name,\n                    { value: attributes[name],\n                        writable: true,\n                        enumerable: true,\n                        configurable: true });\n            }\n        }\n        return desc;\n    }\n\n// store a reference to the real ES5 primitives before patching them later\n    var prim_preventExtensions =        Object.preventExtensions,\n        prim_seal =                     Object.seal,\n        prim_freeze =                   Object.freeze,\n        prim_isExtensible =             Object.isExtensible,\n        prim_isSealed =                 Object.isSealed,\n        prim_isFrozen =                 Object.isFrozen,\n        prim_getPrototypeOf =           Object.getPrototypeOf,\n        prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n        prim_defineProperty =           Object.defineProperty,\n        prim_defineProperties =         Object.defineProperties,\n        prim_keys =                     Object.keys,\n        prim_getOwnPropertyNames =      Object.getOwnPropertyNames,\n        prim_getOwnPropertySymbols =    Object.getOwnPropertySymbols,\n        prim_assign =                   Object.assign,\n        prim_isArray =                  Array.isArray,\n        prim_concat =                   Array.prototype.concat,\n        prim_isPrototypeOf =            Object.prototype.isPrototypeOf,\n        prim_hasOwnProperty =           Object.prototype.hasOwnProperty;\n\n// these will point to the patched versions of the respective methods on\n// Object. They are used within this module as the \"intrinsic\" bindings\n// of these methods (i.e. the \"original\" bindings as defined in the spec)\n    var Object_isFrozen,\n        Object_isSealed,\n        Object_isExtensible,\n        Object_getPrototypeOf,\n        Object_getOwnPropertyNames;\n\n    /**\n     * A property 'name' is fixed if it is an own property of the target.\n     */\n    function isFixed(name, target) {\n        return ({}).hasOwnProperty.call(target, name);\n    }\n    function isSealed(name, target) {\n        var desc = Object.getOwnPropertyDescriptor(target, name);\n        if (desc === undefined) { return false; }\n        return desc.configurable === false;\n    }\n    function isSealedDesc(desc) {\n        return desc !== undefined && desc.configurable === false;\n    }\n\n    /**\n     * Performs all validation that Object.defineProperty performs,\n     * without actually defining the property. Returns a boolean\n     * indicating whether validation succeeded.\n     *\n     * Implementation transliterated from ES5.1 section 8.12.9\n     */\n    function isCompatibleDescriptor(extensible, current, desc) {\n        if (current === undefined && extensible === false) {\n            return false;\n        }\n        if (current === undefined && extensible === true) {\n            return true;\n        }\n        if (isEmptyDescriptor(desc)) {\n            return true;\n        }\n        if (isEquivalentDescriptor(current, desc)) {\n            return true;\n        }\n        if (current.configurable === false) {\n            if (desc.configurable === true) {\n                return false;\n            }\n            if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n                return false;\n            }\n        }\n        if (isGenericDescriptor(desc)) {\n            return true;\n        }\n        if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n            if (current.configurable === false) {\n                return false;\n            }\n            return true;\n        }\n        if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n            if (current.configurable === false) {\n                if (current.writable === false && desc.writable === true) {\n                    return false;\n                }\n                if (current.writable === false) {\n                    if ('value' in desc && !sameValue(desc.value, current.value)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n            if (current.configurable === false) {\n                if ('set' in desc && !sameValue(desc.set, current.set)) {\n                    return false;\n                }\n                if ('get' in desc && !sameValue(desc.get, current.get)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n// ES6 7.3.11 SetIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\n    function setIntegrityLevel(target, level) {\n        var ownProps = Object_getOwnPropertyNames(target);\n        var pendingException = undefined;\n        if (level === \"sealed\") {\n            var l = +ownProps.length;\n            var k;\n            for (var i = 0; i < l; i++) {\n                k = String(ownProps[i]);\n                try {\n                    Object.defineProperty(target, k, { configurable: false });\n                } catch (e) {\n                    if (pendingException === undefined) {\n                        pendingException = e;\n                    }\n                }\n            }\n        } else {\n            // level === \"frozen\"\n            var l = +ownProps.length;\n            var k;\n            for (var i = 0; i < l; i++) {\n                k = String(ownProps[i]);\n                try {\n                    var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n                    if (currentDesc !== undefined) {\n                        var desc;\n                        if (isAccessorDescriptor(currentDesc)) {\n                            desc = { configurable: false }\n                        } else {\n                            desc = { configurable: false, writable: false }\n                        }\n                        Object.defineProperty(target, k, desc);\n                    }\n                } catch (e) {\n                    if (pendingException === undefined) {\n                        pendingException = e;\n                    }\n                }\n            }\n        }\n        if (pendingException !== undefined) {\n            throw pendingException;\n        }\n        return Reflect.preventExtensions(target);\n    }\n\n// ES6 7.3.12 TestIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\n    function testIntegrityLevel(target, level) {\n        var isExtensible = Object_isExtensible(target);\n        if (isExtensible) return false;\n\n        var ownProps = Object_getOwnPropertyNames(target);\n        var pendingException = undefined;\n        var configurable = false;\n        var writable = false;\n\n        var l = +ownProps.length;\n        var k;\n        var currentDesc;\n        for (var i = 0; i < l; i++) {\n            k = String(ownProps[i]);\n            try {\n                currentDesc = Object.getOwnPropertyDescriptor(target, k);\n                configurable = configurable || currentDesc.configurable;\n                if (isDataDescriptor(currentDesc)) {\n                    writable = writable || currentDesc.writable;\n                }\n            } catch (e) {\n                if (pendingException === undefined) {\n                    pendingException = e;\n                    configurable = true;\n                }\n            }\n        }\n        if (pendingException !== undefined) {\n            throw pendingException;\n        }\n        if (level === \"frozen\" && writable === true) {\n            return false;\n        }\n        if (configurable === true) {\n            return false;\n        }\n        return true;\n    }\n\n// ---- The Validator handler wrapper around user handlers ----\n\n    /**\n     * @param target the object wrapped by this proxy.\n     * As long as the proxy is extensible, only non-configurable properties\n     * are checked against the target. Once the proxy becomes non-extensible,\n     * invariants w.r.t. non-extensibility are also enforced.\n     *\n     * @param handler the handler of the direct proxy. The object emulated by\n     * this handler is validated against the target object of the direct proxy.\n     * Any violations that the handler makes against the invariants\n     * of the target will cause a TypeError to be thrown.\n     *\n     * Both target and handler must be proper Objects at initialization time.\n     */\n    function Validator(target, handler) {\n        // for non-revokable proxies, these are const references\n        // for revokable proxies, on revocation:\n        // - this.target is set to null\n        // - this.handler is set to a handler that throws on all traps\n        this.target  = target;\n        this.handler = handler;\n    }\n\n    Validator.prototype = {\n\n        /**\n         * If getTrap returns undefined, the caller should perform the\n         * default forwarding behavior.\n         * If getTrap returns normally otherwise, the return value\n         * will be a callable trap function. When calling the trap function,\n         * the caller is responsible for binding its |this| to |this.handler|.\n         */\n        getTrap: function(trapName) {\n            var trap = this.handler[trapName];\n            if (trap === undefined) {\n                // the trap was not defined,\n                // perform the default forwarding behavior\n                return undefined;\n            }\n\n            if (typeof trap !== \"function\") {\n                throw new TypeError(trapName + \" trap is not callable: \"+trap);\n            }\n\n            return trap;\n        },\n\n        // === fundamental traps ===\n\n        /**\n         * If name denotes a fixed property, check:\n         *   - whether targetHandler reports it as existent\n         *   - whether the returned descriptor is compatible with the fixed property\n         * If the proxy is non-extensible, check:\n         *   - whether name is not a new property\n         * Additionally, the returned descriptor is normalized and completed.\n         */\n        getOwnPropertyDescriptor: function(name) {\n            \"use strict\";\n\n            var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n            if (trap === undefined) {\n                return Reflect.getOwnPropertyDescriptor(this.target, name);\n            }\n\n            name = String(name);\n            var desc = trap.call(this.handler, this.target, name);\n            desc = normalizeAndCompletePropertyDescriptor(desc);\n\n            var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n            var extensible = Object.isExtensible(this.target);\n\n            if (desc === undefined) {\n                if (isSealedDesc(targetDesc)) {\n                    throw new TypeError(\"cannot report non-configurable property '\"+name+\n                        \"' as non-existent\");\n                }\n                if (!extensible && targetDesc !== undefined) {\n                    // if handler is allowed to return undefined, we cannot guarantee\n                    // that it will not return a descriptor for this property later.\n                    // Once a property has been reported as non-existent on a non-extensible\n                    // object, it should forever be reported as non-existent\n                    throw new TypeError(\"cannot report existing own property '\"+name+\n                        \"' as non-existent on a non-extensible object\");\n                }\n                return undefined;\n            }\n\n            // at this point, we know (desc !== undefined), i.e.\n            // targetHandler reports 'name' as an existing property\n\n            // Note: we could collapse the following two if-tests into a single\n            // test. Separating out the cases to improve error reporting.\n\n            if (!extensible) {\n                if (targetDesc === undefined) {\n                    throw new TypeError(\"cannot report a new own property '\"+\n                        name + \"' on a non-extensible object\");\n                }\n            }\n\n            if (name !== undefined) {\n                if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n                    throw new TypeError(\"cannot report incompatible property descriptor \"+\n                        \"for property '\"+name+\"'\");\n                }\n            }\n\n            if (desc.configurable === false) {\n                if (targetDesc === undefined || targetDesc.configurable === true) {\n                    // if the property is configurable or non-existent on the target,\n                    // but is reported as a non-configurable property, it may later be\n                    // reported as configurable or non-existent, which violates the\n                    // invariant that if the property might change or disappear, the\n                    // configurable attribute must be true.\n                    throw new TypeError(\n                        \"cannot report a non-configurable descriptor \" +\n                        \"for configurable or non-existent property '\" + name + \"'\");\n                }\n                if ('writable' in desc && desc.writable === false) {\n                    if (targetDesc.writable === true) {\n                        // if the property is non-configurable, writable on the target,\n                        // but is reported as non-configurable, non-writable, it may later\n                        // be reported as non-configurable, writable again, which violates\n                        // the invariant that a non-configurable, non-writable property\n                        // may not change state.\n                        throw new TypeError(\n                            \"cannot report non-configurable, writable property '\" + name +\n                            \"' as non-configurable, non-writable\");\n                    }\n                }\n            }\n\n            return desc;\n        },\n\n        /**\n         * In the direct proxies design with refactored prototype climbing,\n         * this trap is deprecated. For proxies-as-prototypes, instead\n         * of calling this trap, the get, set, has or enumerate traps are\n         * called instead.\n         *\n         * In this implementation, we \"abuse\" getPropertyDescriptor to\n         * support trapping the get or set traps for proxies-as-prototypes.\n         * We do this by returning a getter/setter pair that invokes\n         * the corresponding traps.\n         *\n         * While this hack works for inherited property access, it has some\n         * quirks:\n         *\n         * In Firefox, this trap is only called after a prior invocation\n         * of the 'has' trap has returned true. Hence, expect the following\n         * behavior:\n         * <code>\n         * var child = Object.create(Proxy(target, handler));\n         * child[name] // triggers handler.has(target, name)\n         * // if that returns true, triggers handler.get(target, name, child)\n         * </code>\n         *\n         * On v8, the 'in' operator, when applied to an object that inherits\n         * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n         * That calls the below getPropertyDescriptor trap on the proxy. The\n         * result of the 'in'-operator is then determined by whether this trap\n         * returns undefined or a property descriptor object. That is why\n         * we first explicitly trigger the 'has' trap to determine whether\n         * the property exists.\n         *\n         * This has the side-effect that when enumerating properties on\n         * an object that inherits from a proxy in v8, only properties\n         * for which 'has' returns true are returned:\n         *\n         * <code>\n         * var child = Object.create(Proxy(target, handler));\n         * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n         * </code>\n         */\n        getPropertyDescriptor: function(name) {\n            var handler = this;\n\n            if (!handler.has(name)) return undefined;\n\n            return {\n                get: function() {\n                    return handler.get(this, name);\n                },\n                set: function(val) {\n                    if (handler.set(this, name, val)) {\n                        return val;\n                    } else {\n                        throw new TypeError(\"failed assignment to \"+name);\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            };\n        },\n\n        /**\n         * If name denotes a fixed property, check for incompatible changes.\n         * If the proxy is non-extensible, check that new properties are rejected.\n         */\n        defineProperty: function(name, desc) {\n            // TODO(tvcutsem): the current tracemonkey implementation of proxies\n            // auto-completes 'desc', which is not correct. 'desc' should be\n            // normalized, but not completed. Consider:\n            // Object.defineProperty(proxy, 'foo', {enumerable:false})\n            // This trap will receive desc =\n            //  {value:undefined,writable:false,enumerable:false,configurable:false}\n            // This will also set all other attributes to their default value,\n            // which is unexpected and different from [[DefineOwnProperty]].\n            // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n            var trap = this.getTrap(\"defineProperty\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.defineProperty(this.target, name, desc);\n            }\n\n            name = String(name);\n            var descObj = normalizePropertyDescriptor(desc);\n            var success = trap.call(this.handler, this.target, name, descObj);\n            success = !!success; // coerce to Boolean\n\n            if (success === true) {\n\n                var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                var extensible = Object.isExtensible(this.target);\n\n                // Note: we could collapse the following two if-tests into a single\n                // test. Separating out the cases to improve error reporting.\n\n                if (!extensible) {\n                    if (targetDesc === undefined) {\n                        throw new TypeError(\"cannot successfully add a new property '\"+\n                            name + \"' to a non-extensible object\");\n                    }\n                }\n\n                if (targetDesc !== undefined) {\n                    if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n                        throw new TypeError(\"cannot define incompatible property \"+\n                            \"descriptor for property '\"+name+\"'\");\n                    }\n                    if (isDataDescriptor(targetDesc) &&\n                        targetDesc.configurable === false &&\n                        targetDesc.writable === true) {\n                        if (desc.configurable === false && desc.writable === false) {\n                            // if the property is non-configurable, writable on the target\n                            // but was successfully reported to be updated to\n                            // non-configurable, non-writable, it can later be reported\n                            // again as non-configurable, writable, which violates\n                            // the invariant that non-configurable, non-writable properties\n                            // cannot change state\n                            throw new TypeError(\n                                \"cannot successfully define non-configurable, writable \" +\n                                \" property '\" + name + \"' as non-configurable, non-writable\");\n                        }\n                    }\n                }\n\n                if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n                    // if the property is configurable or non-existent on the target,\n                    // but is successfully being redefined as a non-configurable property,\n                    // it may later be reported as configurable or non-existent, which violates\n                    // the invariant that if the property might change or disappear, the\n                    // configurable attribute must be true.\n                    throw new TypeError(\n                        \"cannot successfully define a non-configurable \" +\n                        \"descriptor for configurable or non-existent property '\" +\n                        name + \"'\");\n                }\n\n            }\n\n            return success;\n        },\n\n        /**\n         * On success, check whether the target object is indeed non-extensible.\n         */\n        preventExtensions: function() {\n            var trap = this.getTrap(\"preventExtensions\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.preventExtensions(this.target);\n            }\n\n            var success = trap.call(this.handler, this.target);\n            success = !!success; // coerce to Boolean\n            if (success) {\n                if (Object_isExtensible(this.target)) {\n                    throw new TypeError(\"can't report extensible object as non-extensible: \"+\n                        this.target);\n                }\n            }\n            return success;\n        },\n\n        /**\n         * If name denotes a sealed property, check whether handler rejects.\n         */\n        delete: function(name) {\n            \"use strict\";\n            var trap = this.getTrap(\"deleteProperty\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.deleteProperty(this.target, name);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name);\n            res = !!res; // coerce to Boolean\n\n            var targetDesc;\n            if (res === true) {\n                targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                if (targetDesc !== undefined && targetDesc.configurable === false) {\n                    throw new TypeError(\"property '\" + name + \"' is non-configurable \"+\n                        \"and can't be deleted\");\n                }\n                if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n                    // if the property still exists on a non-extensible target but\n                    // is reported as successfully deleted, it may later be reported\n                    // as present, which violates the invariant that an own property,\n                    // deleted from a non-extensible object cannot reappear.\n                    throw new TypeError(\n                        \"cannot successfully delete existing property '\" + name +\n                        \"' on a non-extensible object\");\n                }\n            }\n\n            return res;\n        },\n\n        /**\n         * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n         * which now also returns an array (of strings or symbols) and\n         * which performs the same rigorous invariant checks as getOwnPropertyNames\n         *\n         * See issue #48 on how this trap can still get invoked by external libs\n         * that don't use the patched Object.getOwnPropertyNames function.\n         */\n        getOwnPropertyNames: function() {\n            // Note: removed deprecation warning to avoid dependency on 'console'\n            // (and on node, should anyway use util.deprecate). Deprecation warnings\n            // can also be annoying when they are outside of the user's control, e.g.\n            // when an external library calls unpatched Object.getOwnPropertyNames.\n            // Since there is a clean fallback to `ownKeys`, the fact that the\n            // deprecated method is still called is mostly harmless anyway.\n            // See also issues #65 and #66.\n            // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n            return this.ownKeys();\n        },\n\n        /**\n         * Checks whether the trap result does not contain any new properties\n         * if the proxy is non-extensible.\n         *\n         * Any own non-configurable properties of the target that are not included\n         * in the trap result give rise to a TypeError. As such, we check whether the\n         * returned result contains at least all sealed properties of the target\n         * object.\n         *\n         * Additionally, the trap result is normalized.\n         * Instead of returning the trap result directly:\n         *  - create and return a fresh Array,\n         *  - of which each element is coerced to a String\n         *\n         * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n         * and Object.keys (the latter filters out only the enumerable own properties).\n         */\n        ownKeys: function() {\n            var trap = this.getTrap(\"ownKeys\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.ownKeys(this.target);\n            }\n\n            var trapResult = trap.call(this.handler, this.target);\n\n            // propNames is used as a set of strings\n            var propNames = Object.create(null);\n            var numProps = +trapResult.length;\n            var result = new Array(numProps);\n\n            for (var i = 0; i < numProps; i++) {\n                var s = String(trapResult[i]);\n                if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n                    // non-extensible proxies don't tolerate new own property names\n                    throw new TypeError(\"ownKeys trap cannot list a new \"+\n                        \"property '\"+s+\"' on a non-extensible object\");\n                }\n\n                propNames[s] = true;\n                result[i] = s;\n            }\n\n            var ownProps = Object_getOwnPropertyNames(this.target);\n            var target = this.target;\n            ownProps.forEach(function (ownProp) {\n                if (!propNames[ownProp]) {\n                    if (isSealed(ownProp, target)) {\n                        throw new TypeError(\"ownKeys trap failed to include \"+\n                            \"non-configurable property '\"+ownProp+\"'\");\n                    }\n                    if (!Object.isExtensible(target) &&\n                        isFixed(ownProp, target)) {\n                        // if handler is allowed to report ownProp as non-existent,\n                        // we cannot guarantee that it will never later report it as\n                        // existent. Once a property has been reported as non-existent\n                        // on a non-extensible object, it should forever be reported as\n                        // non-existent\n                        throw new TypeError(\"ownKeys trap cannot report existing own property '\"+\n                            ownProp+\"' as non-existent on a non-extensible object\");\n                    }\n                }\n            });\n\n            return result;\n        },\n\n        /**\n         * Checks whether the trap result is consistent with the state of the\n         * wrapped target.\n         */\n        isExtensible: function() {\n            var trap = this.getTrap(\"isExtensible\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.isExtensible(this.target);\n            }\n\n            var result = trap.call(this.handler, this.target);\n            result = !!result; // coerce to Boolean\n            var state = Object_isExtensible(this.target);\n            if (result !== state) {\n                if (result) {\n                    throw new TypeError(\"cannot report non-extensible object as extensible: \"+\n                        this.target);\n                } else {\n                    throw new TypeError(\"cannot report extensible object as non-extensible: \"+\n                        this.target);\n                }\n            }\n            return state;\n        },\n\n        /**\n         * Check whether the trap result corresponds to the target's [[Prototype]]\n         */\n        getPrototypeOf: function() {\n            var trap = this.getTrap(\"getPrototypeOf\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.getPrototypeOf(this.target);\n            }\n\n            var allegedProto = trap.call(this.handler, this.target);\n\n            if (!Object_isExtensible(this.target)) {\n                var actualProto = Object_getPrototypeOf(this.target);\n                if (!sameValue(allegedProto, actualProto)) {\n                    throw new TypeError(\"prototype value does not match: \" + this.target);\n                }\n            }\n\n            return allegedProto;\n        },\n\n        /**\n         * If target is non-extensible and setPrototypeOf trap returns true,\n         * check whether the trap result corresponds to the target's [[Prototype]]\n         */\n        setPrototypeOf: function(newProto) {\n            var trap = this.getTrap(\"setPrototypeOf\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.setPrototypeOf(this.target, newProto);\n            }\n\n            var success = trap.call(this.handler, this.target, newProto);\n\n            success = !!success;\n            if (success && !Object_isExtensible(this.target)) {\n                var actualProto = Object_getPrototypeOf(this.target);\n                if (!sameValue(newProto, actualProto)) {\n                    throw new TypeError(\"prototype value does not match: \" + this.target);\n                }\n            }\n\n            return success;\n        },\n\n        /**\n         * In the direct proxies design with refactored prototype climbing,\n         * this trap is deprecated. For proxies-as-prototypes, for-in will\n         * call the enumerate() trap. If that trap is not defined, the\n         * operation is forwarded to the target, no more fallback on this\n         * fundamental trap.\n         */\n        getPropertyNames: function() {\n            throw new TypeError(\"getPropertyNames trap is deprecated\");\n        },\n\n        // === derived traps ===\n\n        /**\n         * If name denotes a fixed property, check whether the trap returns true.\n         */\n        has: function(name) {\n            var trap = this.getTrap(\"has\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.has(this.target, name);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name);\n            res = !!res; // coerce to Boolean\n\n            if (res === false) {\n                if (isSealed(name, this.target)) {\n                    throw new TypeError(\"cannot report existing non-configurable own \"+\n                        \"property '\"+ name + \"' as a non-existent \"+\n                        \"property\");\n                }\n                if (!Object.isExtensible(this.target) &&\n                    isFixed(name, this.target)) {\n                    // if handler is allowed to return false, we cannot guarantee\n                    // that it will not return true for this property later.\n                    // Once a property has been reported as non-existent on a non-extensible\n                    // object, it should forever be reported as non-existent\n                    throw new TypeError(\"cannot report existing own property '\"+name+\n                        \"' as non-existent on a non-extensible object\");\n                }\n            }\n\n            // if res === true, we don't need to check for extensibility\n            // even for a non-extensible proxy that has no own name property,\n            // the property may have been inherited\n\n            return res;\n        },\n\n        /**\n         * If name denotes a fixed non-configurable, non-writable data property,\n         * check its return value against the previously asserted value of the\n         * fixed property.\n         */\n        get: function(receiver, name) {\n\n            // experimental support for invoke() trap on platforms that\n            // support __noSuchMethod__\n            /*\n             if (name === '__noSuchMethod__') {\n             var handler = this;\n             return function(name, args) {\n             return handler.invoke(receiver, name, args);\n             }\n             }\n             */\n\n            var trap = this.getTrap(\"get\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.get(this.target, name, receiver);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name, receiver);\n\n            var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n            // check consistency of the returned value\n            if (fixedDesc !== undefined) { // getting an existing property\n                if (isDataDescriptor(fixedDesc) &&\n                    fixedDesc.configurable === false &&\n                    fixedDesc.writable === false) { // own frozen data property\n                    if (!sameValue(res, fixedDesc.value)) {\n                        throw new TypeError(\"cannot report inconsistent value for \"+\n                            \"non-writable, non-configurable property '\"+\n                            name+\"'\");\n                    }\n                } else { // it's an accessor property\n                    if (isAccessorDescriptor(fixedDesc) &&\n                        fixedDesc.configurable === false &&\n                        fixedDesc.get === undefined) {\n                        if (res !== undefined) {\n                            throw new TypeError(\"must report undefined for non-configurable \"+\n                                \"accessor property '\"+name+\"' without getter\");\n                        }\n                    }\n                }\n            }\n\n            return res;\n        },\n\n        /**\n         * If name denotes a fixed non-configurable, non-writable data property,\n         * check that the trap rejects the assignment.\n         */\n        set: function(receiver, name, val) {\n            var trap = this.getTrap(\"set\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.set(this.target, name, val, receiver);\n            }\n\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name, val, receiver);\n            res = !!res; // coerce to Boolean\n\n            // if success is reported, check whether property is truly assignable\n            if (res === true) {\n                var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                if (fixedDesc !== undefined) { // setting an existing property\n                    if (isDataDescriptor(fixedDesc) &&\n                        fixedDesc.configurable === false &&\n                        fixedDesc.writable === false) {\n                        if (!sameValue(val, fixedDesc.value)) {\n                            throw new TypeError(\"cannot successfully assign to a \"+\n                                \"non-writable, non-configurable property '\"+\n                                name+\"'\");\n                        }\n                    } else {\n                        if (isAccessorDescriptor(fixedDesc) &&\n                            fixedDesc.configurable === false && // non-configurable\n                            fixedDesc.set === undefined) {      // accessor with undefined setter\n                            throw new TypeError(\"setting a property '\"+name+\"' that has \"+\n                                \" only a getter\");\n                        }\n                    }\n                }\n            }\n\n            return res;\n        },\n\n        /**\n         * Any own enumerable non-configurable properties of the target that are not\n         * included in the trap result give rise to a TypeError. As such, we check\n         * whether the returned result contains at least all sealed enumerable properties\n         * of the target object.\n         *\n         * The trap should return an iterator.\n         *\n         * However, as implementations of pre-direct proxies still expect enumerate\n         * to return an array of strings, we convert the iterator into an array.\n         */\n        enumerate: function() {\n            var trap = this.getTrap(\"enumerate\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                var trapResult = Reflect.enumerate(this.target);\n                var result = [];\n                var nxt = trapResult.next();\n                while (!nxt.done) {\n                    result.push(String(nxt.value));\n                    nxt = trapResult.next();\n                }\n                return result;\n            }\n\n            var trapResult = trap.call(this.handler, this.target);\n\n            if (trapResult === null ||\n                trapResult === undefined ||\n                trapResult.next === undefined) {\n                throw new TypeError(\"enumerate trap should return an iterator, got: \"+\n                    trapResult);\n            }\n\n            // propNames is used as a set of strings\n            var propNames = Object.create(null);\n\n            // var numProps = +trapResult.length;\n            var result = []; // new Array(numProps);\n\n            // trapResult is supposed to be an iterator\n            // drain iterator to array as current implementations still expect\n            // enumerate to return an array of strings\n            var nxt = trapResult.next();\n\n            while (!nxt.done) {\n                var s = String(nxt.value);\n                if (propNames[s]) {\n                    throw new TypeError(\"enumerate trap cannot list a \"+\n                        \"duplicate property '\"+s+\"'\");\n                }\n                propNames[s] = true;\n                result.push(s);\n                nxt = trapResult.next();\n            }\n\n            /*for (var i = 0; i < numProps; i++) {\n             var s = String(trapResult[i]);\n             if (propNames[s]) {\n             throw new TypeError(\"enumerate trap cannot list a \"+\n             \"duplicate property '\"+s+\"'\");\n             }\n             propNames[s] = true;\n             result[i] = s;\n             } */\n\n            var ownEnumerableProps = Object.keys(this.target);\n            var target = this.target;\n            ownEnumerableProps.forEach(function (ownEnumerableProp) {\n                if (!propNames[ownEnumerableProp]) {\n                    if (isSealed(ownEnumerableProp, target)) {\n                        throw new TypeError(\"enumerate trap failed to include \"+\n                            \"non-configurable enumerable property '\"+\n                            ownEnumerableProp+\"'\");\n                    }\n                    if (!Object.isExtensible(target) &&\n                        isFixed(ownEnumerableProp, target)) {\n                        // if handler is allowed not to report ownEnumerableProp as an own\n                        // property, we cannot guarantee that it will never report it as\n                        // an own property later. Once a property has been reported as\n                        // non-existent on a non-extensible object, it should forever be\n                        // reported as non-existent\n                        throw new TypeError(\"cannot report existing own property '\"+\n                            ownEnumerableProp+\"' as non-existent on a \"+\n                            \"non-extensible object\");\n                    }\n                }\n            });\n\n            return result;\n        },\n\n        /**\n         * The iterate trap is deprecated by the enumerate trap.\n         */\n        iterate: Validator.prototype.enumerate,\n\n        /**\n         * Any own non-configurable properties of the target that are not included\n         * in the trap result give rise to a TypeError. As such, we check whether the\n         * returned result contains at least all sealed properties of the target\n         * object.\n         *\n         * The trap result is normalized.\n         * The trap result is not returned directly. Instead:\n         *  - create and return a fresh Array,\n         *  - of which each element is coerced to String,\n         *  - which does not contain duplicates\n         *\n         * FIXME: keys trap is deprecated\n         */\n        /*\n         keys: function() {\n         var trap = this.getTrap(\"keys\");\n         if (trap === undefined) {\n         // default forwarding behavior\n         return Reflect.keys(this.target);\n         }\n         var trapResult = trap.call(this.handler, this.target);\n         // propNames is used as a set of strings\n         var propNames = Object.create(null);\n         var numProps = +trapResult.length;\n         var result = new Array(numProps);\n         for (var i = 0; i < numProps; i++) {\n         var s = String(trapResult[i]);\n         if (propNames[s]) {\n         throw new TypeError(\"keys trap cannot list a \"+\n         \"duplicate property '\"+s+\"'\");\n         }\n         if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n         // non-extensible proxies don't tolerate new own property names\n         throw new TypeError(\"keys trap cannot list a new \"+\n         \"property '\"+s+\"' on a non-extensible object\");\n         }\n         propNames[s] = true;\n         result[i] = s;\n         }\n         var ownEnumerableProps = Object.keys(this.target);\n         var target = this.target;\n         ownEnumerableProps.forEach(function (ownEnumerableProp) {\n         if (!propNames[ownEnumerableProp]) {\n         if (isSealed(ownEnumerableProp, target)) {\n         throw new TypeError(\"keys trap failed to include \"+\n         \"non-configurable enumerable property '\"+\n         ownEnumerableProp+\"'\");\n         }\n         if (!Object.isExtensible(target) &&\n         isFixed(ownEnumerableProp, target)) {\n         // if handler is allowed not to report ownEnumerableProp as an own\n         // property, we cannot guarantee that it will never report it as\n         // an own property later. Once a property has been reported as\n         // non-existent on a non-extensible object, it should forever be\n         // reported as non-existent\n         throw new TypeError(\"cannot report existing own property '\"+\n         ownEnumerableProp+\"' as non-existent on a \"+\n         \"non-extensible object\");\n         }\n         }\n         });\n         return result;\n         },\n         */\n\n        /**\n         * New trap that reifies [[Call]].\n         * If the target is a function, then a call to\n         *   proxy(...args)\n         * Triggers this trap\n         */\n        apply: function(target, thisBinding, args) {\n            var trap = this.getTrap(\"apply\");\n            if (trap === undefined) {\n                return Reflect.apply(target, thisBinding, args);\n            }\n\n            if (typeof this.target === \"function\") {\n                return trap.call(this.handler, target, thisBinding, args);\n            } else {\n                throw new TypeError(\"apply: \"+ target + \" is not a function\");\n            }\n        },\n\n        /**\n         * New trap that reifies [[Construct]].\n         * If the target is a function, then a call to\n         *   new proxy(...args)\n         * Triggers this trap\n         */\n        construct: function(target, args, newTarget) {\n            var trap = this.getTrap(\"construct\");\n            if (trap === undefined) {\n                return Reflect.construct(target, args, newTarget);\n            }\n\n            if (typeof target !== \"function\") {\n                throw new TypeError(\"new: \"+ target + \" is not a function\");\n            }\n\n            if (newTarget === undefined) {\n                newTarget = target;\n            } else {\n                if (typeof newTarget !== \"function\") {\n                    throw new TypeError(\"new: \"+ newTarget + \" is not a function\");\n                }\n            }\n            return trap.call(this.handler, target, args, newTarget);\n        }\n    };\n\n// ---- end of the Validator handler wrapper handler ----\n\n// In what follows, a 'direct proxy' is a proxy\n// whose handler is a Validator. Such proxies can be made non-extensible,\n// sealed or frozen without losing the ability to trap.\n\n// maps direct proxies to their Validator handlers\n    var directProxies = new WeakMap();\n\n// patch Object.{preventExtensions,seal,freeze} so that\n// they recognize fixable proxies and act accordingly\n    Object.preventExtensions = function(subject) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            if (vhandler.preventExtensions()) {\n                return subject;\n            } else {\n                throw new TypeError(\"preventExtensions on \"+subject+\" rejected\");\n            }\n        } else {\n            return prim_preventExtensions(subject);\n        }\n    };\n    Object.seal = function(subject) {\n        setIntegrityLevel(subject, \"sealed\");\n        return subject;\n    };\n    Object.freeze = function(subject) {\n        setIntegrityLevel(subject, \"frozen\");\n        return subject;\n    };\n    Object.isExtensible = Object_isExtensible = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.isExtensible();\n        } else {\n            return prim_isExtensible(subject);\n        }\n    };\n    Object.isSealed = Object_isSealed = function(subject) {\n        return testIntegrityLevel(subject, \"sealed\");\n    };\n    Object.isFrozen = Object_isFrozen = function(subject) {\n        return testIntegrityLevel(subject, \"frozen\");\n    };\n    Object.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.getPrototypeOf();\n        } else {\n            return prim_getPrototypeOf(subject);\n        }\n    };\n\n// patch Object.getOwnPropertyDescriptor to directly call\n// the Validator.prototype.getOwnPropertyDescriptor trap\n// This is to circumvent an assertion in the built-in Proxy\n// trapping mechanism of v8, which disallows that trap to\n// return non-configurable property descriptors (as per the\n// old Proxy design)\n    Object.getOwnPropertyDescriptor = function(subject, name) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            return vhandler.getOwnPropertyDescriptor(name);\n        } else {\n            return prim_getOwnPropertyDescriptor(subject, name);\n        }\n    };\n\n// patch Object.defineProperty to directly call\n// the Validator.prototype.defineProperty trap\n// This is to circumvent two issues with the built-in\n// trap mechanism:\n// 1) the current tracemonkey implementation of proxies\n// auto-completes 'desc', which is not correct. 'desc' should be\n// normalized, but not completed. Consider:\n// Object.defineProperty(proxy, 'foo', {enumerable:false})\n// This trap will receive desc =\n//  {value:undefined,writable:false,enumerable:false,configurable:false}\n// This will also set all other attributes to their default value,\n// which is unexpected and different from [[DefineOwnProperty]].\n// Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n// 2) the current spidermonkey implementation does not\n// throw an exception when this trap returns 'false', but instead silently\n// ignores the operation (this is regardless of strict-mode)\n// 2a) v8 does throw an exception for this case, but includes the rather\n//     unhelpful error message:\n// 'Proxy handler #<Object> returned false from 'defineProperty' trap'\n    Object.defineProperty = function(subject, name, desc) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            var normalizedDesc = normalizePropertyDescriptor(desc);\n            var success = vhandler.defineProperty(name, normalizedDesc);\n            if (success === false) {\n                throw new TypeError(\"can't redefine property '\"+name+\"'\");\n            }\n            return subject;\n        } else {\n            return prim_defineProperty(subject, name, desc);\n        }\n    };\n\n    Object.defineProperties = function(subject, descs) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            var names = Object.keys(descs);\n            for (var i = 0; i < names.length; i++) {\n                var name = names[i];\n                var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n                var success = vhandler.defineProperty(name, normalizedDesc);\n                if (success === false) {\n                    throw new TypeError(\"can't redefine property '\"+name+\"'\");\n                }\n            }\n            return subject;\n        } else {\n            return prim_defineProperties(subject, descs);\n        }\n    };\n\n    Object.keys = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            var ownKeys = vHandler.ownKeys();\n            var result = [];\n            for (var i = 0; i < ownKeys.length; i++) {\n                var k = String(ownKeys[i]);\n                var desc = Object.getOwnPropertyDescriptor(subject, k);\n                if (desc !== undefined && desc.enumerable === true) {\n                    result.push(k);\n                }\n            }\n            return result;\n        } else {\n            return prim_keys(subject);\n        }\n    }\n\n    Object.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.ownKeys();\n        } else {\n            return prim_getOwnPropertyNames(subject);\n        }\n    }\n\n// fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n// throws an error)\n    if (prim_getOwnPropertySymbols !== undefined) {\n        Object.getOwnPropertySymbols = function(subject) {\n            var vHandler = directProxies.get(subject);\n            if (vHandler !== undefined) {\n                // as this shim does not support symbols, a Proxy never advertises\n                // any symbol-valued own properties\n                return [];\n            } else {\n                return prim_getOwnPropertySymbols(subject);\n            }\n        };\n    }\n\n// fixes issue #72 ('Illegal access' error when using Object.assign)\n// Object.assign polyfill based on a polyfill posted on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n//  Global_Objects/Object/assign\n// Note that this polyfill does not support Symbols, but this Proxy Shim\n// does not support Symbols anyway.\n    if (prim_assign !== undefined) {\n        Object.assign = function (target) {\n\n            // check if any argument is a proxy object\n            var noProxies = true;\n            for (var i = 0; i < arguments.length; i++) {\n                var vHandler = directProxies.get(arguments[i]);\n                if (vHandler !== undefined) {\n                    noProxies = false;\n                    break;\n                }\n            }\n            if (noProxies) {\n                // not a single argument is a proxy, perform built-in algorithm\n                return prim_assign.apply(Object, arguments);\n            }\n\n            // there is at least one proxy argument, use the polyfill\n\n            if (target === undefined || target === null) {\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var output = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for (var nextKey in source) {\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    }\n\n// returns whether an argument is a reference to an object,\n// which is legal as a WeakMap key.\n    function isObject(arg) {\n        var type = typeof arg;\n        return (type === 'object' && arg !== null) || (type === 'function');\n    };\n\n// a wrapper for WeakMap.get which returns the undefined value\n// for keys that are not objects (in which case the underlying\n// WeakMap would have thrown a TypeError).\n    function safeWeakMapGet(map, key) {\n        return isObject(key) ? map.get(key) : undefined;\n    };\n\n// returns a new function of zero arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a zero-argument method\n// that uses its |this|-binding.\n    function makeUnwrapping0ArgMethod(primitive) {\n        return function builtin() {\n            var vHandler = safeWeakMapGet(directProxies, this);\n            if (vHandler !== undefined) {\n                return builtin.call(vHandler.target);\n            } else {\n                return primitive.call(this);\n            }\n        }\n    };\n\n// returns a new function of 1 arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a 1-argument method\n// that uses its |this|-binding.\n    function makeUnwrapping1ArgMethod(primitive) {\n        return function builtin(arg) {\n            var vHandler = safeWeakMapGet(directProxies, this);\n            if (vHandler !== undefined) {\n                return builtin.call(vHandler.target, arg);\n            } else {\n                return primitive.call(this, arg);\n            }\n        }\n    };\n\n    Object.prototype.valueOf =\n        makeUnwrapping0ArgMethod(Object.prototype.valueOf);\n    Object.prototype.toString =\n        makeUnwrapping0ArgMethod(Object.prototype.toString);\n    Function.prototype.toString =\n        makeUnwrapping0ArgMethod(Function.prototype.toString);\n    Date.prototype.toString =\n        makeUnwrapping0ArgMethod(Date.prototype.toString);\n\n    Object.prototype.isPrototypeOf = function builtin(arg) {\n        // bugfix thanks to Bill Mark:\n        // built-in isPrototypeOf does not unwrap proxies used\n        // as arguments. So, we implement the builtin ourselves,\n        // based on the ECMAScript 6 spec. Our encoding will\n        // make sure that if a proxy is used as an argument,\n        // its getPrototypeOf trap will be called.\n        while (true) {\n            var vHandler2 = safeWeakMapGet(directProxies, arg);\n            if (vHandler2 !== undefined) {\n                arg = vHandler2.getPrototypeOf();\n                if (arg === null) {\n                    return false;\n                } else if (sameValue(arg, this)) {\n                    return true;\n                }\n            } else {\n                return prim_isPrototypeOf.call(this, arg);\n            }\n        }\n    };\n\n    Array.isArray = function(subject) {\n        var vHandler = safeWeakMapGet(directProxies, subject);\n        if (vHandler !== undefined) {\n            return Array.isArray(vHandler.target);\n        } else {\n            return prim_isArray(subject);\n        }\n    };\n\n    function isProxyArray(arg) {\n        var vHandler = safeWeakMapGet(directProxies, arg);\n        if (vHandler !== undefined) {\n            return Array.isArray(vHandler.target);\n        }\n        return false;\n    }\n\n// Array.prototype.concat internally tests whether one of its\n// arguments is an Array, by checking whether [[Class]] == \"Array\"\n// As such, it will fail to recognize proxies-for-arrays as arrays.\n// We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n// by making a copy. This will trigger the exact same sequence of\n// traps on the proxy-for-array as if we would not have unwrapped it.\n// See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\n    Array.prototype.concat = function(/*...args*/) {\n        var length;\n        for (var i = 0; i < arguments.length; i++) {\n            if (isProxyArray(arguments[i])) {\n                length = arguments[i].length;\n                arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n            }\n        }\n        return prim_concat.apply(this, arguments);\n    };\n\n// setPrototypeOf support on platforms that support __proto__\n\n    var prim_setPrototypeOf = Object.setPrototypeOf;\n\n// patch and extract original __proto__ setter\n    var __proto__setter = (function() {\n        var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype,'__proto__');\n        if (protoDesc === undefined ||\n            typeof protoDesc.set !== \"function\") {\n            return function() {\n                throw new TypeError(\"setPrototypeOf not supported on this platform\");\n            }\n        }\n\n        // see if we can actually mutate a prototype with the generic setter\n        // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n        try {\n            protoDesc.set.call({},{});\n        } catch (e) {\n            return function() {\n                throw new TypeError(\"setPrototypeOf not supported on this platform\");\n            }\n        }\n\n        prim_defineProperty(Object.prototype, '__proto__', {\n            set: function(newProto) {\n                return Object.setPrototypeOf(this, Object(newProto));\n            }\n        });\n\n        return protoDesc.set;\n    }());\n\n    Object.setPrototypeOf = function(target, newProto) {\n        var handler = directProxies.get(target);\n        if (handler !== undefined) {\n            if (handler.setPrototypeOf(newProto)) {\n                return target;\n            } else {\n                throw new TypeError(\"proxy rejected prototype mutation\");\n            }\n        } else {\n            if (!Object_isExtensible(target)) {\n                throw new TypeError(\"can't set prototype on non-extensible object: \" +\n                    target);\n            }\n            if (prim_setPrototypeOf)\n                return prim_setPrototypeOf(target, newProto);\n\n            if (Object(newProto) !== newProto || newProto === null) {\n                throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                    newProto);\n                // throw new TypeError(\"prototype must be an object or null\")\n            }\n            __proto__setter.call(target, newProto);\n            return target;\n        }\n    }\n\n    Object.prototype.hasOwnProperty = function(name) {\n        var handler = safeWeakMapGet(directProxies, this);\n        if (handler !== undefined) {\n            var desc = handler.getOwnPropertyDescriptor(name);\n            return desc !== undefined;\n        } else {\n            return prim_hasOwnProperty.call(this, name);\n        }\n    }\n\n// ============= Reflection module =============\n// see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\n    var Reflect = global.Reflect = {\n        getOwnPropertyDescriptor: function(target, name) {\n            return Object.getOwnPropertyDescriptor(target, name);\n        },\n        defineProperty: function(target, name, desc) {\n\n            // if target is a proxy, invoke its \"defineProperty\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.defineProperty(target, name, desc);\n            }\n\n            // Implementation transliterated from [[DefineOwnProperty]]\n            // see ES5.1 section 8.12.9\n            // this is the _exact same algorithm_ as the isCompatibleDescriptor\n            // algorithm defined above, except that at every place it\n            // returns true, this algorithm actually does define the property.\n            var current = Object.getOwnPropertyDescriptor(target, name);\n            var extensible = Object.isExtensible(target);\n            if (current === undefined && extensible === false) {\n                return false;\n            }\n            if (current === undefined && extensible === true) {\n                Object.defineProperty(target, name, desc); // should never fail\n                return true;\n            }\n            if (isEmptyDescriptor(desc)) {\n                return true;\n            }\n            if (isEquivalentDescriptor(current, desc)) {\n                return true;\n            }\n            if (current.configurable === false) {\n                if (desc.configurable === true) {\n                    return false;\n                }\n                if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n                    return false;\n                }\n            }\n            if (isGenericDescriptor(desc)) {\n                // no further validation necessary\n            } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n                if (current.configurable === false) {\n                    return false;\n                }\n            } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n                if (current.configurable === false) {\n                    if (current.writable === false && desc.writable === true) {\n                        return false;\n                    }\n                    if (current.writable === false) {\n                        if ('value' in desc && !sameValue(desc.value, current.value)) {\n                            return false;\n                        }\n                    }\n                }\n            } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n                if (current.configurable === false) {\n                    if ('set' in desc && !sameValue(desc.set, current.set)) {\n                        return false;\n                    }\n                    if ('get' in desc && !sameValue(desc.get, current.get)) {\n                        return false;\n                    }\n                }\n            }\n            Object.defineProperty(target, name, desc); // should never fail\n            return true;\n        },\n        deleteProperty: function(target, name) {\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.delete(name);\n            }\n\n            var desc = Object.getOwnPropertyDescriptor(target, name);\n            if (desc === undefined) {\n                return true;\n            }\n            if (desc.configurable === true) {\n                delete target[name];\n                return true;\n            }\n            return false;\n        },\n        getPrototypeOf: function(target) {\n            return Object.getPrototypeOf(target);\n        },\n        setPrototypeOf: function(target, newProto) {\n\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.setPrototypeOf(newProto);\n            }\n\n            if (Object(newProto) !== newProto || newProto === null) {\n                throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                    newProto);\n            }\n\n            if (!Object_isExtensible(target)) {\n                return false;\n            }\n\n            var current = Object.getPrototypeOf(target);\n            if (sameValue(current, newProto)) {\n                return true;\n            }\n\n            if (prim_setPrototypeOf) {\n                try {\n                    prim_setPrototypeOf(target, newProto);\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n\n            __proto__setter.call(target, newProto);\n            return true;\n        },\n        preventExtensions: function(target) {\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.preventExtensions();\n            }\n            prim_preventExtensions(target);\n            return true;\n        },\n        isExtensible: function(target) {\n            return Object.isExtensible(target);\n        },\n        has: function(target, name) {\n            return name in target;\n        },\n        get: function(target, name, receiver) {\n            receiver = receiver || target;\n\n            // if target is a proxy, invoke its \"get\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.get(receiver, name);\n            }\n\n            var desc = Object.getOwnPropertyDescriptor(target, name);\n            if (desc === undefined) {\n                var proto = Object.getPrototypeOf(target);\n                if (proto === null) {\n                    return undefined;\n                }\n                return Reflect.get(proto, name, receiver);\n            }\n            if (isDataDescriptor(desc)) {\n                return desc.value;\n            }\n            var getter = desc.get;\n            if (getter === undefined) {\n                return undefined;\n            }\n            return desc.get.call(receiver);\n        },\n        // Reflect.set implementation based on latest version of [[SetP]] at\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n        set: function(target, name, value, receiver) {\n            receiver = receiver || target;\n\n            // if target is a proxy, invoke its \"set\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.set(receiver, name, value);\n            }\n\n            // first, check whether target has a non-writable property\n            // shadowing name on receiver\n            var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n            if (ownDesc === undefined) {\n                // name is not defined in target, search target's prototype\n                var proto = Object.getPrototypeOf(target);\n\n                if (proto !== null) {\n                    // continue the search in target's prototype\n                    return Reflect.set(proto, name, value, receiver);\n                }\n\n                // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n                // target was the last prototype, now we know that 'name' is not shadowed\n                // by an existing (accessor or data) property, so we can add the property\n                // to the initial receiver object\n                // (this branch will intentionally fall through to the code below)\n                ownDesc =\n                { value: undefined,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true };\n            }\n\n            // we now know that ownDesc !== undefined\n            if (isAccessorDescriptor(ownDesc)) {\n                var setter = ownDesc.set;\n                if (setter === undefined) return false;\n                setter.call(receiver, value); // assumes Function.prototype.call\n                return true;\n            }\n            // otherwise, isDataDescriptor(ownDesc) must be true\n            if (ownDesc.writable === false) return false;\n            // we found an existing writable data property on the prototype chain.\n            // Now update or add the data property on the receiver, depending on\n            // whether the receiver already defines the property or not.\n            var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n            if (existingDesc !== undefined) {\n                var updateDesc =\n                { value: value,\n                    // FIXME: it should not be necessary to describe the following\n                    // attributes. Added to circumvent a bug in tracemonkey:\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n                    writable:     existingDesc.writable,\n                    enumerable:   existingDesc.enumerable,\n                    configurable: existingDesc.configurable };\n                Object.defineProperty(receiver, name, updateDesc);\n                return true;\n            } else {\n                if (!Object.isExtensible(receiver)) return false;\n                var newDesc =\n                { value: value,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true };\n                Object.defineProperty(receiver, name, newDesc);\n                return true;\n            }\n        },\n        /*invoke: function(target, name, args, receiver) {\n         receiver = receiver || target;\n         var handler = directProxies.get(target);\n         if (handler !== undefined) {\n         return handler.invoke(receiver, name, args);\n         }\n         var fun = Reflect.get(target, name, receiver);\n         return Function.prototype.apply.call(fun, receiver, args);\n         },*/\n        enumerate: function(target) {\n            var handler = directProxies.get(target);\n            var result;\n            if (handler !== undefined) {\n                // handler.enumerate should return an iterator directly, but the\n                // iterator gets converted to an array for backward-compat reasons,\n                // so we must re-iterate over the array\n                result = handler.enumerate(handler.target);\n            } else {\n                result = [];\n                for (var name in target) { result.push(name); };\n            }\n            var l = +result.length;\n            var idx = 0;\n            return {\n                next: function() {\n                    if (idx === l) return { done: true };\n                    return { done: false, value: result[idx++] };\n                }\n            };\n        },\n        // imperfect ownKeys implementation: in ES6, should also include\n        // symbol-keyed properties.\n        ownKeys: function(target) {\n            return Object_getOwnPropertyNames(target);\n        },\n        apply: function(target, receiver, args) {\n            // target.apply(receiver, args)\n            return Function.prototype.apply.call(target, receiver, args);\n        },\n        construct: function(target, args, newTarget) {\n            // return new target(...args);\n\n            // if target is a proxy, invoke its \"construct\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.construct(handler.target, args, newTarget);\n            }\n\n            if (typeof target !== \"function\") {\n                throw new TypeError(\"target is not a function: \" + target);\n            }\n            if (newTarget === undefined) {\n                newTarget = target;\n            } else {\n                if (typeof newTarget !== \"function\") {\n                    throw new TypeError(\"newTarget is not a function: \" + target);\n                }\n            }\n\n            return new (Function.prototype.bind.apply(newTarget, [null].concat(args)));\n        }\n    };\n\n// feature-test whether the Proxy global exists, with\n// the harmony-era Proxy.create API\n    if (typeof Proxy !== \"undefined\" &&\n        typeof Proxy.create !== \"undefined\") {\n\n        var primCreate = Proxy.create,\n            primCreateFunction = Proxy.createFunction;\n\n        var revokedHandler = primCreate({\n            get: function() { throw new TypeError(\"proxy is revoked\"); }\n        });\n\n        global.Proxy = function(target, handler) {\n            // check that target is an Object\n            if (Object(target) !== target) {\n                throw new TypeError(\"Proxy target must be an Object, given \"+target);\n            }\n            // check that handler is an Object\n            if (Object(handler) !== handler) {\n                throw new TypeError(\"Proxy handler must be an Object, given \"+handler);\n            }\n\n            var vHandler = new Validator(target, handler);\n            var proxy;\n            if (typeof target === \"function\") {\n                proxy = primCreateFunction(vHandler,\n                    // call trap\n                    function() {\n                        var args = Array.prototype.slice.call(arguments);\n                        return vHandler.apply(target, this, args);\n                    },\n                    // construct trap\n                    function() {\n                        var args = Array.prototype.slice.call(arguments);\n                        return vHandler.construct(target, args);\n                    });\n            } else {\n                proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n            }\n            directProxies.set(proxy, vHandler);\n            return proxy;\n        };\n\n        global.Proxy.revocable = function(target, handler) {\n            var proxy = new Proxy(target, handler);\n            var revoke = function() {\n                var vHandler = directProxies.get(proxy);\n                if (vHandler !== null) {\n                    vHandler.target  = null;\n                    vHandler.handler = revokedHandler;\n                }\n                return undefined;\n            };\n            return {proxy: proxy, revoke: revoke};\n        }\n\n        // add the old Proxy.create and Proxy.createFunction methods\n        // so old code that still depends on the harmony-era Proxy object\n        // is not broken. Also ensures that multiple versions of this\n        // library should load fine\n        global.Proxy.create = primCreate;\n        global.Proxy.createFunction = primCreateFunction;\n\n    } else {\n        // Proxy global not defined, or old API not available\n        if (typeof Proxy === \"undefined\") {\n            // Proxy global not defined, add a Proxy function stub\n            global.Proxy = function(_target, _handler) {\n                throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n            };\n        }\n        // Proxy global defined but old API not available\n        // presumably Proxy global already supports new API, leave untouched\n    }\n\n// for node.js modules, export every property in the Reflect object\n// as part of the module interface\n    if (typeof exports !== 'undefined') {\n        Object.keys(Reflect).forEach(function (key) {\n            exports[key] = Reflect[key];\n        });\n    }\n\n// function-as-module pattern\n}(window));\n\n\n/**\n * Returns an object which allows for safe navigation of properties.\n * When raw property values are needed, simply execute the property as a function.\n *\n * e.g.\n * let nnObject = nn({ a: 1 });\n * nnObject.a() == 1\n * nnObject.non.existent.property.access() == undefined\n *\n * @param rawValue - object to be wrapped.\n * @returns {Proxy}\n */\nconst nn = (rawValue)=>{\n\n    //Each property accessed on a nevernull function-object will be this function.\n    //e.g. nn({}).prop1 is a function, which when executed, returns the passed in rawValue.\n    let wrappedValue = ()=>{\n        return rawValue;\n    };\n\n    //intercept all property access on the wrappedValue function-object\n    return new Proxy(wrappedValue, {\n\n        /**\n         * When a property is accessed, this function intercepts its access and instead returns a Proxy of a wrappedValue function.\n         * This allows us to do lazy recursion on all nested properties.\n         * @param target - object which is being asked for the property with the name of the 'name' parameter.\n         * @param name - property name on the target who's value is needed.\n         * @returns {Proxy} - recursive call to nevernull is returned so accessing nested properties is always safe.\n         */\n        get: function(target, name){\n            //get the raw target so we can access the raw property value.\n            let rawTarget = target();\n            let rawPropertyValue = rawTarget ? rawTarget[name] : undefined;\n\n            //function properties should maintain their context.\n            if(typeof rawPropertyValue === 'function'){\n                rawPropertyValue = rawPropertyValue.bind(rawTarget);\n            }\n\n            //ensure the property is never null.\n            return nn(rawPropertyValue);\n        }\n    });\n};\n"]}